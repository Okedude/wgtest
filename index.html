<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Herr Winkelmann</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: 'Roboto Mono', monospace;
            color: #333;
            overflow: hidden;
            transition: background-color 2s ease-in-out;
            user-select: none;
        }
        .game-container {
            display: none; /* Initial hide */
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        }
        canvas {
            background-color: #a4d3ff;
            border-radius: 10px;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.2);
            touch-action: none;
        }
        .ui-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 600px;
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f8f8;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        .stats-container {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 15px;
            text-align: center;
        }
        .stat-item {
            font-size: 1.1em;
            font-weight: bold;
        }
        .progress-bar {
            width: 80%;
            height: 25px;
            background-color: #ddd;
            border-radius: 12px;
            overflow: hidden;
            margin-top: 5px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff7e5f, #feb47b);
            transition: width 0.5s ease-out;
        }
        #lungen-kapazitaet-bar {
            background: linear-gradient(90deg, #4CAF50, #8bc34a);
        }
        .info-message {
            margin-top: 15px;
            font-size: 1.2em;
            text-align: center;
            line-height: 1.4;
        }
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(255, 0, 0, 0);
            color: white;
            font-size: 3em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            opacity: 0;
            visibility: hidden;
            transition: background-color 2s, opacity 2s;
            z-index: 1000;
        }
        .overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .win-overlay {
            background-color: rgba(76, 175, 80, 0.7);
        }
        .button {
            padding: 12px 24px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background: linear-gradient(145deg, #f8a141, #ff7e5f);
            color: white;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: 20px;
        }
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
        }
        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .level-info {
            font-size: 1.2em;
            margin-bottom: 10px;
            font-weight: bold;
        }
        .level-progress-bar {
            width: 100%;
            height: 10px;
            background-color: #ddd;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 5px;
        }
        .level-progress-bar-fill {
            height: 100%;
            background-color: #f8a141;
            transition: width 0.5s ease-out;
        }
        /* Dialogue box styles */
        .dialogue-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .dialogue-box {
            background-color: #fff;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 500px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .dialogue-title {
            font-size: 1.5em;
            font-weight: bold;
        }
        .dialogue-text {
            border: 2px solid #ddd;
            padding: 15px;
            border-radius: 10px;
            min-height: 80px;
            background-color: #f9f9f9;
            text-align: left;
            overflow-y: auto;
            max-height: 200px;
            line-height: 1.4;
        }
        .dialogue-input-container {
            display: flex;
            gap: 10px;
        }
        .dialogue-input {
            flex-grow: 1;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: 'Roboto Mono', monospace;
            font-size: 1em;
        }
        .dialogue-button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: #ff7e5f;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }
        .dialogue-button:hover {
            background: #feb47b;
        }
        .dialogue-close-button {
            align-self: flex-end;
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: #999;
        }
        .level-select-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }
        .level-select-container {
            background-color: #fff;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 600px;
            max-height: 90%;
            overflow-y: auto;
            text-align: center;
        }
        .level-select-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }
        .level-button {
            padding: 15px;
            font-size: 1.2em;
            font-weight: bold;
            border: 2px solid #ddd;
            border-radius: 8px;
            background-color: #f0f0f0;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            position: relative;
        }
        .level-button:hover:not(:disabled) {
            background-color: #e0e0e0;
            border-color: #ff7e5f;
        }
        .level-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #ccc;
        }
        .level-button .lock-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            fill: #666;
            transition: transform 0.3s ease-in-out;
            opacity: 1;
        }
        .level-button.unlocked .lock-icon {
            animation: unlock-fade 0.5s ease-in-out forwards;
            opacity: 0;
        }
        @keyframes unlock-fade {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 0;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
            }
        }

        /* --- Login/Registration UI --- */
        .auth-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px;
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        .auth-container h2 {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 20px;
        }
        .auth-container input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: 'Roboto Mono', monospace;
            font-size: 1em;
            transition: border-color 0.2s;
        }
        .auth-container input:focus {
            outline: none;
            border-color: #ff7e5f;
        }
        .auth-container button {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            background: linear-gradient(145deg, #f8a141, #ff7e5f);
            color: white;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .auth-container button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
        }
        .auth-container button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .auth-container p {
            margin-top: 15px;
            font-size: 0.9em;
        }
        .auth-container a {
            color: #ff7e5f;
            cursor: pointer;
            text-decoration: underline;
        }
        #userInfo {
            font-size: 1em;
            text-align: center;
            margin-bottom: 10px;
        }

        /* Button styles for Google login */
        #googleLoginButton {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            background: linear-gradient(145deg, #4285F4, #34609a);
            color: white;
            margin-top: 15px;
            padding: 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
            font-size: 1em;
        }
        #googleLoginButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
        }
        #googleLoginButton:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        #googleLoginButton svg {
            width: 20px;
            height: 20px;
        }
    </style>
</head>
<body>
    <div class="auth-container" id="authContainer">
        <div id="loadingMessage">Lade Spiel...</div>
        <div id="authForms" style="display: none;">
            <div id="loginForm">
                <h2>Anmelden</h2>
                <input type="email" id="loginEmail" placeholder="E-Mail">
                <input type="password" id="loginPassword" placeholder="Passwort">
                <button id="loginButton">Anmelden</button>
                <p>Noch kein Konto? <a href="#" id="showRegister">Jetzt registrieren</a></p>
                <p id="authError" style="color: red;"></p>
            </div>
            <div id="registerForm" style="display: none;">
                <h2>Registrieren</h2>
                <input type="email" id="registerEmail" placeholder="E-Mail">
                <input type="password" id="registerPassword" placeholder="Passwort">
                <button id="registerButton">Registrieren</button>
                <p>Bereits ein Konto? <a href="#" id="showLogin">Zurück zur Anmeldung</a></p>
                <p id="registerError" style="color: red;"></p>
            </div>

            <hr style="width: 80%; border: 1px solid #ddd; margin: 20px 0;">

            <button id="googleLoginButton">
                <svg viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M44.5 20H24V28H35.5C34.7 32.7 30.6 35.5 24 35.5C18.6 35.5 13.9 31.8 11.9 26.5C11.3 25.1 11 23.6 11 22C11 20.4 11.3 18.9 11.9 17.5C13.9 12.2 18.6 8.5 24 8.5C28.2 8.5 31.7 10.1 34.3 12.7L39.1 7.9C35.2 4.1 29.8 2 24 2C13.8 2 5.5 9.7 2.7 20H44.5V20Z" fill="#F4B400"/>
                    <path d="M24 35.5C30.6 35.5 34.7 32.7 35.5 28H24V35.5Z" fill="#DB4437"/>
                    <path d="M11.9 26.5C11.3 25.1 11 23.6 11 22C11 20.4 11.3 18.9 11.9 17.5C13.9 12.2 18.6 8.5 24 8.5C28.2 8.5 31.7 10.1 34.3 12.7L39.1 7.9C35.2 4.1 29.8 2 24 2C13.8 2 5.5 9.7 2.7 20L11.9 26.5Z" fill="#4285F4"/>
                    <path d="M2.7 20C2.1 21.3 2 22.7 2 24C2 25.3 2.1 26.7 2.7 28L11.9 21.5L2.7 20Z" fill="#0F9D58"/>
                </svg>
                Mit Google anmelden
            </button>
        </div>
    </div>

    <div class="game-container" id="gameContainer">
        <div id="userInfo"></div>
        <div class="level-info" id="level-info">Level 1</div>
        <canvas id="gameCanvas"></canvas>
        <div class="ui-panel">
            <div class="stats-container">
                <div class="stat-item">
                    Lungenkapazität<br>
                    <span id="lungen-kapazitaet-text">100%</span>
                    <div class="progress-bar">
                        <div class="progress-bar-fill" id="lungen-kapazitaet-bar"></div>
                    </div>
                </div>
                <div class="stat-item">
                    Stiele gesammelt<br>
                    <span id="stiele-counter">0 / 5</span>
                </div>
            </div>
            <div class="info-message" id="info-message">Bewegen Sie sich mit den Pfeiltasten oder WASD. Sammeln Sie alle Stiele, um das Level zu beenden.</div>
            <div style="display: flex; gap: 10px;">
                <button class="button" id="openDialogueButton">✨ Lass uns reden!</button>
                <button class="button" id="openLevelSelectButton">Level-Auswahl</button>
                <button class="button" id="logoutButton">Abmelden</button>
            </div>
        </div>
    </div>
    <div class="overlay" id="overlay">
        <span id="overlay-text"></span>
    </div>

    <!-- Dialogue UI -->
    <div class="dialogue-overlay" id="dialogueOverlay">
        <div class="dialogue-box">
            <button class="dialogue-close-button" id="closeDialogueButton">&times;</button>
            <div class="dialogue-title">Herr Winkelmann sagt...</div>
            <div class="dialogue-text" id="dialogueText">Fragen Sie mich alles, aber bitte nicht, wie viele Stiele ich noch brauche... Bin schon ganz aus der Puste!</div>
            <div class="dialogue-input-container">
                <input type="text" id="dialogueInput" class="dialogue-input" placeholder="Stellen Sie eine Frage...">
                <button class="dialogue-button" id="sendDialogueButton">Senden</button>
            </div>
        </div>
    </div>

    <!-- Level Select UI -->
    <div class="level-select-overlay" id="levelSelectOverlay">
        <div class="level-select-container">
            <div class="dialogue-title">Wähle ein Level</div>
            <div class="level-select-grid" id="levelSelectGrid"></div>
            <button class="button" style="margin-top: 20px;" id="closeLevelSelectButton">Schließen</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, linkWithCredential, EmailAuthProvider, GoogleAuthProvider, signInWithPopup } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // WICHTIG: Ersetzen Sie die Platzhalter unten durch Ihre eigenen Firebase-Projektdaten
        // Eine Anleitung dazu finden Sie in der Konversation.
        const firebaseConfig = {
          apiKey: "AIzaSyCoP3TRsVluxrVXVxeZ_lJfeOyqrNbbGa0",
          authDomain: "winkelmanngame.firebaseapp.com",
          projectId: "winkelmanngame",
          storageBucket: "winkelmanngame.firebasestorage.app",
          messagingSenderId: "1012811950512",
          appId: "1:1012811950512:web:61d506f84c217eb156ce75",
          measurementId: "G-FDH9FT3QYR"
        };
        const initialAuthToken = null;
        const appId = firebaseConfig.appId;

        let app, db, auth;
        let highestLevel = 1;
        let userId;

        // UI element references
        const authContainer = document.getElementById('authContainer');
        const authForms = document.getElementById('authForms');
        const loadingMessage = document.getElementById('loadingMessage');
        const gameContainer = document.getElementById('gameContainer');
        const loginForm = document.getElementById('loginForm');
        const registerForm = document.getElementById('registerForm');
        const showRegisterLink = document.getElementById('showRegister');
        const showLoginLink = document.getElementById('showLogin');
        const loginEmailInput = document.getElementById('loginEmail');
        const loginPasswordInput = document.getElementById('loginPassword');
        const loginButton = document.getElementById('loginButton');
        const registerEmailInput = document.getElementById('registerEmail');
        const registerPasswordInput = document.getElementById('registerPassword');
        const registerButton = document.getElementById('registerButton');
        const authError = document.getElementById('authError');
        const registerError = document.getElementById('registerError');
        const userInfoDisplay = document.getElementById('userInfo');
        const logoutButton = document.getElementById('logoutButton');
        const googleLoginButton = document.getElementById('googleLoginButton');

        // Main application flow, to be called after Firebase init
        async function startAppFlow() {
            // Check if Firebase was initialized successfully
            if (!auth || !db) {
                console.error("Firebase not initialized. Cannot start app flow.");
                loadingMessage.textContent = "Fehler: Firebase-Konfiguration ungültig. Bitte überprüfen Sie Ihre Daten.";
                return;
            }

            // Authentication Event Listeners
            showRegisterLink.addEventListener('click', (e) => {
                e.preventDefault();
                loginForm.style.display = 'none';
                registerForm.style.display = 'block';
                authError.textContent = '';
            });

            showLoginLink.addEventListener('click', (e) => {
                e.preventDefault();
                loginForm.style.display = 'block';
                registerForm.style.display = 'none';
                registerError.textContent = '';
            });

            loginButton.addEventListener('click', async () => {
                const email = loginEmailInput.value;
                const password = loginPasswordInput.value;
                authError.textContent = '';
                try {
                    await signInWithEmailAndPassword(auth, email, password);
                } catch (error) {
                    authError.textContent = 'Login fehlgeschlagen. Bitte überprüfen Sie E-Mail und Passwort.';
                    console.error("Login failed:", error);
                }
            });

            registerButton.addEventListener('click', async () => {
                const email = registerEmailInput.value;
                const password = registerPasswordInput.value;
                registerError.textContent = '';
                try {
                    await createUserWithEmailAndPassword(auth, email, password);
                } catch (error) {
                    if (error.code === 'auth/email-already-in-use') {
                        registerError.textContent = 'Diese E-Mail-Adresse wird bereits verwendet.';
                    } else {
                        registerError.textContent = 'Registrierung fehlgeschlagen. Bitte versuchen Sie es erneut.';
                    }
                    console.error("Registration failed:", error);
                }
            });

            googleLoginButton.addEventListener('click', async () => {
                const provider = new GoogleAuthProvider();
                authError.textContent = '';
                try {
                    await signInWithPopup(auth, provider);
                } catch (error) {
                    authError.textContent = 'Anmeldung mit Google fehlgeschlagen.';
                    console.error("Google login failed:", error);
                }
            });

            logoutButton.addEventListener('click', async () => {
                try {
                    await signOut(auth);
                } catch (error) {
                    console.error("Logout failed:", error);
                }
            });
            
            // Main Auth State Listener
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    // User is signed in. This is triggered after anonymous sign-in or email/password sign-in.
                    userId = user.uid;
                    userInfoDisplay.textContent = `Angemeldet als: ${user.email || 'Anonym'}`;
                    authContainer.style.display = 'none';
                    gameContainer.style.display = 'flex';
                    
                    // Fetch highest level from Firestore
                    const gameDocRef = doc(db, 'artifacts', appId, 'users', userId, 'gameData', 'progress');
                    try {
                        const docSnap = await getDoc(gameDocRef);
                        if (docSnap.exists()) {
                            highestLevel = docSnap.data().highestLevel;
                            console.log("Progress loaded from Firestore. Highest level:", highestLevel);
                        } else {
                            // Create a new document if it doesn't exist
                            await setDoc(gameDocRef, { highestLevel: 1 });
                            console.log("New progress document created.");
                        }
                    } catch (error) {
                        console.error("Error fetching or creating user data:", error);
                    }

                    initializeGame();
                    
                } else {
                    // User is signed out.
                    userInfoDisplay.textContent = '';
                    authContainer.style.display = 'flex';
                    gameContainer.style.display = 'none';
                    console.log("User logged out.");
                    
                    // Show auth forms and hide loading message
                    loadingMessage.style.display = 'none';
                    authForms.style.display = 'block';

                    // For github.io, we need to sign in anonymously on load
                    signInAnonymously(auth)
                        .then(() => console.log("Signed in anonymously."))
                        .catch(e => console.error("Firebase anonymous sign-in failed:", e));
                }
            });

            // Initial sign-in attempt
            signInAnonymously(auth)
                .then(() => console.log("Signed in anonymously."))
                .catch(e => console.error("Firebase anonymous sign-in failed:", e));
        }

        // The entire game logic, wrapped in a function to be called after auth state is determined
        async function initializeGame() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const overlay = document.getElementById('overlay');
            const overlayText = document.getElementById('overlay-text');
            const lungenKapazitaetBar = document.getElementById('lungen-kapazitaet-bar');
            const lungenKapazitaetText = document.getElementById('lungen-kapazitaet-text');
            const stieleCounterText = document.getElementById('stiele-counter');
            const infoMessage = document.getElementById('info-message');
            const levelInfo = document.getElementById('level-info');
            
            // UI elements
            const openDialogueButton = document.getElementById('openDialogueButton');
            const dialogueOverlay = document.getElementById('dialogueOverlay');
            const dialogueText = document.getElementById('dialogueText');
            const dialogueInput = document.getElementById('dialogueInput');
            const sendDialogueButton = document.getElementById('sendDialogueButton');
            const closeDialogueButton = document.getElementById('closeDialogueButton');
            const openLevelSelectButton = document.getElementById('openLevelSelectButton');
            const levelSelectOverlay = document.getElementById('levelSelectOverlay');
            const levelSelectGrid = document.getElementById('levelSelectGrid');
            const closeLevelSelectButton = document.getElementById('closeLevelSelectButton');

            let animationFrameId;
            let lastTime = 0;
            let keys = {};
            let isRunning = false;
            let gameData = { level: 1 };
            let isSpeaking = false;
            let lowLungsWarning = false;

            const baseSpeed = 250;
            const maxLungenKapazitaet = 100;
            const TOTAL_LEVELS = 50;
            const INITIAL_OBSTACLES = 1;

            // Class for game objects
            class GameObject {
                constructor(x, y, width, height, color) {
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                    this.color = color;
                }
                draw() {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }

            // Class for moving obstacles
            class MovingObstacle extends GameObject {
                constructor(x, y, width, height, color, dx, dy, speed) {
                    super(x, y, width, height, color);
                    this.dx = dx;
                    this.dy = dy;
                    this.speed = speed;
                }
                update(deltaTime) {
                    this.x += this.dx * this.speed * deltaTime;
                    this.y += this.dy * this.speed * deltaTime;

                    // Bounce off walls
                    if (this.x <= 0 || this.x + this.width >= canvas.width) {
                        this.dx *= -1;
                    }
                    if (this.y <= 0 || this.y + this.height >= canvas.height) {
                        this.dy *= -1;
                    }
                }
            }

            // Function to get level settings dynamically
            function getLevelSettings(level) {
                const requiredStiele = Math.min(50, 5 + Math.floor(level * 1.5));
                const obstacles = Math.min(20, INITIAL_OBSTACLES + Math.floor(level / 2));
                const lungenDrainRate = 1 + (level - 1) * 0.1;
                const lungLossOnHit = 15 + (level - 1) * 2;
                const obstacleSpeed = 100 + (level - 1) * 10;
                
                return {
                    requiredStiele: requiredStiele,
                    initialStiele: 5,
                    obstacles: obstacles,
                    lungenDrainRate: lungenDrainRate,
                    lungLossOnHit: lungLossOnHit,
                    obstacleSpeed: obstacleSpeed,
                };
            }

            function getNonOverlappingPosition(existingObjects, width, height) {
                let newPos, overlapping;
                do {
                    overlapping = false;
                    newPos = {
                        x: Math.random() * (canvas.width - width),
                        y: Math.random() * (canvas.height - height),
                        width: width,
                        height: height
                    };
                    
                    if (checkCollision(gameData.herrWinkelmann, newPos)) {
                        overlapping = true;
                        continue;
                    }
                    
                    for (const obj of existingObjects) {
                        if (checkCollision(obj, newPos)) {
                            overlapping = true;
                            break;
                        }
                    }
                } while (overlapping);
                return newPos;
            }

            // --- Gemini TTS API Integration ---
            const TTS_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=";
            const API_KEY = ""; // Die API-Schlüssel für Gemini werden in dieser Umgebung von der Plattform bereitgestellt.

            async function speak(text, voiceName = "Kore") {
                if (isSpeaking) return;
                isSpeaking = true;
                
                try {
                    const payload = {
                        contents: [{ parts: [{ text }] }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName }
                                }
                            }
                        },
                        model: "gemini-2.5-flash-preview-tts"
                    };

                    const response = await fetch(TTS_API_URL + API_KEY, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`API error: ${response.statusText}`);
                    }

                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        const audioUrl = URL.createObjectURL(wavBlob);

                        const audio = new Audio(audioUrl);
                        audio.play();
                        audio.onended = () => {
                            URL.revokeObjectURL(audioUrl);
                            isSpeaking = false;
                        };
                    } else {
                        throw new Error("Invalid audio data from API");
                    }
                } catch (error) {
                    console.error("Failed to generate speech:", error);
                    isSpeaking = false;
                }
            }

            function base64ToArrayBuffer(base64) {
                const binaryString = window.atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }

            function pcmToWav(pcmData, sampleRate) {
                const numChannels = 1;
                const bytesPerSample = 2;
                const blockAlign = numChannels * bytesPerSample;
                const byteRate = sampleRate * blockAlign;

                const wavHeader = new ArrayBuffer(44);
                const view = new DataView(wavHeader);

                // RIFF chunk
                writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + pcmData.byteLength, true); // ChunkSize
                writeString(view, 8, 'WAVE');

                // fmt chunk
                writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true); // Subchunk1Size
                view.setUint16(20, 1, true); // AudioFormat (1=PCM)
                view.setUint16(22, numChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, byteRate, true);
                view.setUint16(32, blockAlign, true);
                view.setUint16(34, 16, true); // BitsPerSample

                // data chunk
                writeString(view, 36, 'data');
                view.setUint32(40, pcmData.byteLength, true);

                const blob = new Blob([wavHeader, pcmData], { type: 'audio/wav' });
                return blob;
            }

            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }
            // --- End of Gemini TTS API Integration ---

            // --- Gemini LLM Dialogue Integration ---
            const LLM_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=";
            const systemPrompt = `Du bist Herr Winkelmann, ein sehr höflicher, leicht außer Atem geratener Mann, der damit beschäftigt ist, Stiele einzusammeln. Antworte immer kurz, freundlich und in der Ich-Form. Deine Antworten sollten widerspiegeln, dass du dich gerade anstrengst, aber fest entschlossen bist. Beziehe dich auf deine aktuelle Aufgabe, wenn es passt. Du bist ein einfacher Mann. Vermeide übermäßig komplexe Sprache.`;
            let isGeneratingResponse = false;

            async function generateAndSpeakResponse(userQuery) {
                if (isGeneratingResponse) return;
                isGeneratingResponse = true;
                sendDialogueButton.disabled = true;
                dialogueInput.disabled = true;
                dialogueText.textContent = "Herr Winkelmann denkt nach...";

                try {
                    const payload = {
                        contents: [{ parts: [{ text: userQuery }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                    };

                    const response = await fetch(LLM_API_URL + API_KEY, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`API error: ${response.statusText}`);
                    }

                    const result = await response.json();
                    const text = result?.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (text) {
                        dialogueText.textContent = text;
                        await speak(text, "Leda");
                    } else {
                        throw new Error("Invalid response from LLM API");
                    }
                } catch (error) {
                    console.error("Failed to generate dialogue:", error);
                    dialogueText.textContent = "Huch, etwas ist schiefgelaufen. Ich kann jetzt nicht reden.";
                } finally {
                    isGeneratingResponse = false;
                    sendDialogueButton.disabled = false;
                    dialogueInput.disabled = false;
                }
            }
            // --- End of Gemini LLM Dialogue Integration ---

            async function saveHighestLevel(level) {
                if (level > highestLevel) {
                    highestLevel = level;
                    const gameDocRef = doc(db, 'artifacts', appId, 'users', userId, 'gameData', 'progress');
                    await setDoc(gameDocRef, { highestLevel: highestLevel }, { merge: true });
                    return true;
                }
                return false;
            }

            function resizeCanvas() {
                canvas.width = window.innerWidth * 0.7;
                canvas.height = window.innerHeight * 0.7;
                if (canvas.width > 800) canvas.width = 800;
                if (canvas.height > 600) canvas.height = 600;
                resetGame();
            }

            function generateStiele(count) {
                const existingObjects = [...gameData.stiele, ...gameData.obstacles];
                for (let i = 0; i < count; i++) {
                    const pos = getNonOverlappingPosition(existingObjects, 15, 15);
                    gameData.stiele.push(new GameObject(pos.x, pos.y, 15, 15, 'orange'));
                }
            }

            function resetGame(level = 1) {
                cancelAnimationFrame(animationFrameId);
                isRunning = false;
                gameData.level = level;

                const settings = getLevelSettings(gameData.level);

                gameData = {
                    ...gameData,
                    herrWinkelmann: {
                        x: canvas.width / 2,
                        y: canvas.height / 2,
                        width: 30,
                        height: 30,
                        speed: baseSpeed,
                    },
                    stiele: [],
                    obstacles: [],
                    stielCounter: 0,
                    lungenKapazitaet: maxLungenKapazitaet,
                    requiredStiele: settings.requiredStiele,
                };

                // Generate Moving Obstacles
                const existingObjects = [gameData.herrWinkelmann];
                for (let i = 0; i < settings.obstacles; i++) {
                    const obstacleSize = Math.random() * 30 + 30;
                    const pos = getNonOverlappingPosition(existingObjects, obstacleSize, obstacleSize);
                    const dx = Math.random() > 0.5 ? 1 : -1;
                    const dy = Math.random() > 0.5 ? 1 : -1;
                    const newObstacle = new MovingObstacle(pos.x, pos.y, obstacleSize, obstacleSize, 'black', dx, dy, settings.obstacleSpeed);
                    gameData.obstacles.push(newObstacle);
                    existingObjects.push(newObstacle);
                }
                
                // Initial Stiel generation
                generateStiele(settings.initialStiele);

                draw();
                updateUI();
                showOverlay("Willkommen! Sammle die Stiele!", false);
            }

            function startGame() {
                overlay.classList.remove('active');
                if (!isRunning) {
                    isRunning = true;
                    lastTime = performance.now();
                    animationFrameId = requestAnimationFrame(gameLoop);
                    infoMessage.textContent = "Sammle die Stiele, bevor die Lungenkapazität aufgebraucht ist!";
                    speak("Los geht's! Nur nicht schlapp machen!");
                }
            }

            function gameLoop(time) {
                const deltaTime = (time - lastTime) / 1000;
                lastTime = time;

                if (isRunning) {
                    update(deltaTime);
                    draw();
                    animationFrameId = requestAnimationFrame(gameLoop);
                }
            }

            function update(deltaTime) {
                const settings = getLevelSettings(gameData.level);
                // Handle Movement
                const speed = baseSpeed;
                let dx = 0;
                let dy = 0;
                if (keys['ArrowUp'] || keys['w']) dy = -1;
                if (keys['ArrowDown'] || keys['s']) dy = 1;
                if (keys['ArrowLeft'] || keys['a']) dx = -1;
                if (keys['ArrowRight'] || keys['d']) dx = 1;

                if (dx !== 0 || dy !== 0) {
                    const length = Math.sqrt(dx * dx + dy * dy);
                    if (length > 0) {
                        gameData.herrWinkelmann.x += (dx / length) * speed * deltaTime;
                        gameData.herrWinkelmann.y += (dy / length) * speed * deltaTime;
                    }
                }

                // Boundary Check
                gameData.herrWinkelmann.x = Math.max(0, Math.min(canvas.width - gameData.herrWinkelmann.width, gameData.herrWinkelmann.x));
                gameData.herrWinkelmann.y = Math.max(0, Math.min(canvas.height - gameData.herrWinkelmann.height, gameData.herrWinkelmann.y));

                // Lungenkapazitäts-Drain
                gameData.lungenKapazitaet -= settings.lungenDrainRate * deltaTime;
                if (gameData.lungenKapazitaet <= 0) {
                    endLevel(false, "Da gibt's nichts mehr...");
                    return;
                }
                
                // Low lung capacity warning
                if (gameData.lungenKapazitaet < 20 && !lowLungsWarning) {
                    speak("Uff... die Luft wird knapp!", "Orus");
                    lowLungsWarning = true;
                } else if (gameData.lungenKapazitaet > 20) {
                    lowLungsWarning = false;
                }
                
                // Collision Detection with Stiele
                gameData.stiele.forEach((stiel, index) => {
                    if (checkCollision(gameData.herrWinkelmann, stiel)) {
                        gameData.stiele.splice(index, 1);
                        gameData.stielCounter++;
                        gameData.lungenKapazitaet = Math.min(maxLungenKapazitaet, gameData.lungenKapazitaet + 10);
                        
                        if (gameData.stielCounter >= gameData.requiredStiele) {
                            endLevel(true, "Winkelmann dankt.");
                            return;
                        }
                    }
                });

                // Check for dynamic stiel generation
                if (gameData.stiele.length === 0 && gameData.stielCounter < gameData.requiredStiele) {
                    const stieleToGenerate = Math.min(5, gameData.requiredStiele - gameData.stielCounter);
                    generateStiele(stieleToGenerate);
                }

                // Update and check for collision with Moving Obstacles
                gameData.obstacles.forEach(obstacle => {
                    obstacle.update(deltaTime);
                    if (checkCollision(gameData.herrWinkelmann, obstacle)) {
                        gameData.lungenKapazitaet -= settings.lungLossOnHit;
                        speak("Aua! Das tat weh!", "Charon");
                    }
                });

                updateUI();
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw Stiele
                gameData.stiele.forEach(stiel => {
                    ctx.beginPath();
                    ctx.arc(stiel.x + stiel.width / 2, stiel.y + stiel.height / 2, stiel.width / 2, 0, 2 * Math.PI);
                    ctx.fillStyle = '#ff7e5f';
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
                
                // Draw Obstacles
                gameData.obstacles.forEach(obstacle => {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                });

                // Draw Herr Winkelmann
                ctx.fillStyle = '#3f51b5';
                ctx.fillRect(gameData.herrWinkelmann.x, gameData.herrWinkelmann.y, gameData.herrWinkelmann.width, gameData.herrWinkelmann.height);
            }

            function updateUI() {
                const lungenProzent = Math.max(0, (gameData.lungenKapazitaet / maxLungenKapazitaet) * 100);
                lungenKapazitaetBar.style.width = `${lungenProzent}%`;
                lungenKapazitaetText.textContent = `${Math.floor(lungenProzent)}%`;

                const lungenColor = lungenProzent > 50 ? '#4CAF50' : (lungenProzent > 20 ? '#FFC107' : '#F4436');
                lungenKapazitaetBar.style.background = `linear-gradient(90deg, ${lungenColor}, ${lungenProzent > 50 ? '#8bc34a' : (lungenProzent > 20 ? '#ffeb3b' : '#ff7979')})`;
                
                stieleCounterText.textContent = `${gameData.stielCounter} / ${gameData.requiredStiele}`;
                levelInfo.textContent = `Level ${gameData.level}`;
                
                infoMessage.textContent = "Bewegen Sie sich mit den Pfeiltasten oder WASD. Sammeln Sie alle Stiele, um das Level zu beenden.";
            }

            function showOverlay(text, isWin) {
                overlayText.textContent = text;
                overlay.style.backgroundColor = isWin ? 'rgba(76, 175, 80, 0.7)' : 'rgba(255, 0, 0, 0.7)';
                overlay.classList.add('active');
            }

            function endLevel(isWin, message) {
                isRunning = false;
                cancelAnimationFrame(animationFrameId);
                showOverlay(message, isWin);

                let delay = isWin ? 2000 : 1000;
                
                if (isWin) {
                    const levelUnlocked = saveHighestLevel(gameData.level + 1);
                    speak("Das war eine Meisterleistung!", "Zephyr");
                    if (levelUnlocked) {
                         setTimeout(() => {
                            const newLevelButton = document.getElementById(`level-button-${gameData.level + 1}`);
                            if (newLevelButton) {
                                newLevelButton.disabled = false;
                                newLevelButton.classList.add('unlocked');
                                setTimeout(() => newLevelButton.classList.remove('unlocked'), 1000);
                            }
                         }, delay / 2);
                    }
                } else {
                    speak("Da gibt's nichts mehr...", "Charon");
                }
                
                setTimeout(openLevelSelect, delay);
            }

            function checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            // Level selection logic
            function populateLevelSelect() {
                levelSelectGrid.innerHTML = '';
                for (let i = 1; i <= TOTAL_LEVELS; i++) {
                    const button = document.createElement('button');
                    button.textContent = i;
                    button.id = `level-button-${i}`;
                    button.className = 'level-button';
                    if (i > highestLevel) {
                        button.disabled = true;
                        button.innerHTML += `
                            <svg class="lock-icon" viewBox="0 0 24 24">
                                <path d="M18,11H17A1,1,0,0,0,16,12v2a1,1,0,0,0,1,1h1a1,1,0,0,0,1-1V12A1,1,0,0,0,18,11Zm-5,6a5,5,0,1,0-5-5A5,5,0,0,0,13,17ZM13,9a3,3,0,1,1-3-3A3,3,0,0,1,13,9Z"/>
                            </svg>
                        `;
                    }
                    button.addEventListener('click', () => {
                        resetGame(i);
                        closeLevelSelect();
                        startGame();
                    });
                    levelSelectGrid.appendChild(button);
                }
            }

            function openDialogue() {
                dialogueOverlay.style.display = 'flex';
                isRunning = false;
                cancelAnimationFrame(animationFrameId);
            }

            function closeDialogue() {
                dialogueOverlay.style.display = 'none';
                if (gameData.lungenKapazitaet > 0) {
                    startGame();
                }
            }

            function openLevelSelect() {
                populateLevelSelect();
                levelSelectOverlay.style.display = 'flex';
                isRunning = false;
                cancelAnimationFrame(animationFrameId);
                overlay.classList.remove('active');
            }

            function closeLevelSelect() {
                levelSelectOverlay.style.display = 'none';
                if (gameData.lungenKapazitaet > 0) {
                    startGame();
                }
            }

            document.addEventListener('keydown', (e) => {
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd'].includes(e.key.toLowerCase())) {
                    keys[e.key.toLowerCase()] = true;
                    if (!isRunning && overlay.classList.contains('active')) {
                         startGame();
                    }
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            openDialogueButton.addEventListener('click', openDialogue);
            closeDialogueButton.addEventListener('click', closeDialogue);
            sendDialogueButton.addEventListener('click', () => {
                const userQuery = dialogueInput.value.trim();
                if (userQuery) {
                    generateAndSpeakResponse(userQuery);
                    dialogueInput.value = '';
                }
            });
            dialogueInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    sendDialogueButton.click();
                }
            });
            openLevelSelectButton.addEventListener('click', openLevelSelect);
            closeLevelSelectButton.addEventListener('click', closeLevelSelect);
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            resetGame(highestLevel);
        }
        
        // Try to initialize Firebase. All app logic is dependent on this.
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            console.log("Firebase initialized successfully.");
            startAppFlow();
        } catch (e) {
            console.error("Firebase initialization failed. Please check the provided firebaseConfig.", e);
            loadingMessage.textContent = "Fehler: Verbindung zur Datenbank fehlgeschlagen. Bitte versuchen Sie es später erneut.";
            loadingMessage.style.color = "red";
            loadingMessage.style.fontSize = "1.2em";
            loadingMessage.style.fontWeight = "bold";
        }
    </script>
</body>
</html>
