<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Herr Winkelmann</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: 'Roboto Mono', monospace;
            color: #333;
            overflow: hidden;
            transition: background-color 2s ease-in-out;
            user-select: none;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            max-width: 90%;
            margin: auto;
        }
        canvas {
            background-color: #a4d3ff;
            border-radius: 10px;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.2);
            touch-action: none;
        }
        .ui-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 600px;
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f8f8;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        .stats-container {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 15px;
            text-align: center;
            gap: 10px;
        }
        .stat-item {
            font-size: 1.1em;
            font-weight: bold;
            flex-grow: 1;
        }
        .progress-bar {
            width: 80%;
            height: 25px;
            background-color: #ddd;
            border-radius: 12px;
            overflow: hidden;
            margin-top: 5px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff7e5f, #feb47b);
            transition: width 0.5s ease-out;
        }
        #lungen-kapazitaet-bar {
            background: linear-gradient(90deg, #4CAF50, #8bc34a);
        }
        .info-message {
            margin-top: 15px;
            font-size: 1.2em;
            text-align: center;
            line-height: 1.4;
        }
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(255, 0, 0, 0);
            color: white;
            font-size: 3em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            opacity: 0;
            visibility: hidden;
            transition: background-color 2s, opacity 2s;
            z-index: 1000;
        }
        .overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .win-overlay {
            background-color: rgba(76, 175, 80, 0.7);
        }
        .button {
            padding: 12px 24px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background: linear-gradient(145deg, #f8a141, #ff7e5f);
            color: white;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: 20px;
        }
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
        }
        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .level-info {
            font-size: 1.2em;
            margin-bottom: 10px;
            font-weight: bold;
        }
        .level-progress-bar {
            width: 100%;
            height: 10px;
            background-color: #ddd;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 5px;
        }
        .level-progress-bar-fill {
            height: 100%;
            background-color: #f8a141;
            transition: width 0.5s ease-out;
        }
        /* Dialogue box styles */
        .dialogue-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .dialogue-box {
            background-color: #fff;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 500px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .dialogue-title {
            font-size: 1.5em;
            font-weight: bold;
        }
        .dialogue-text {
            border: 2px solid #ddd;
            padding: 15px;
            border-radius: 10px;
            min-height: 80px;
            background-color: #f9f9f9;
            text-align: left;
            overflow-y: auto;
            max-height: 200px;
            line-height: 1.4;
        }
        .dialogue-input-container {
            display: flex;
            gap: 10px;
        }
        .dialogue-input {
            flex-grow: 1;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: 'Roboto Mono', monospace;
            font-size: 1em;
        }
        .dialogue-button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: #ff7e5f;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }
        .dialogue-button:hover {
            background: #feb47b;
        }
        .dialogue-close-button {
            align-self: flex-end;
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: #999;
        }
        .level-select-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }
        .level-select-container {
            background-color: #fff;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 600px;
            max-height: 90%;
            overflow-y: auto;
            text-align: center;
        }
        .level-select-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }
        .level-button {
            padding: 15px;
            font-size: 1.2em;
            font-weight: bold;
            border: 2px solid #ddd;
            border-radius: 8px;
            background-color: #f0f0f0;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            position: relative;
        }
        .level-button:hover:not(:disabled) {
            background-color: #e0e0e0;
            border-color: #ff7e5f;
        }
        .level-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #ccc;
        }
        .level-button .lock-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            fill: #666;
            transition: transform 0.3s ease-in-out;
            opacity: 1;
        }
        .level-button.unlocked .lock-icon {
            animation: unlock-fade 0.5s ease-in-out forwards;
            opacity: 0;
        }
        @keyframes unlock-fade {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 0;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
            }
        }

        /* --- Login/Registration UI --- */
        .auth-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px;
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        .auth-container h2 {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 20px;
        }
        .auth-container input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: 'Roboto Mono', monospace;
            font-size: 1em;
            transition: border-color 0.2s;
        }
        .auth-container input:focus {
            outline: none;
            border-color: #ff7e5f;
        }
        .auth-container button {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            background: linear-gradient(145deg, #f8a141, #ff7e5f);
            color: white;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .auth-container button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
        }
        .auth-container button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .auth-container p {
            margin-top: 15px;
            font-size: 0.9em;
        }
        .auth-container a {
            color: #ff7e5f;
            cursor: pointer;
            text-decoration: underline;
        }
        #userInfo {
            font-size: 1em;
            text-align: center;
            margin-bottom: 10px;
        }

        /* Button styles for Google login */
        #googleLoginButton {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            background: linear-gradient(145deg, #4285F4, #34609a);
            color: white;
            margin-top: 15px;
            padding: 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
            font-size: 1em;
        }
        #googleLoginButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
        }
        #googleLoginButton:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        #googleLoginButton svg {
            width: 20px;
            height: 20px;
        }
        
        /* Leaderboard and user list */
        .player-list {
            margin-top: 20px;
            width: 100%;
            background-color: #fff;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            text-align: left;
        }
        .player-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #ddd;
        }
        .player-item:last-child {
            border-bottom: none;
        }
        .player-item.current {
            font-weight: bold;
            color: #ff7e5f;
        }
    </style>
</head>
<body>
    <div class="auth-container" id="authContainer" style="display: none;">
        <div id="loadingMessage">Lade Spiel...</div>
        <div id="authForms" style="display: none;">
            <div id="loginForm">
                <h2>Anmelden</h2>
                <input type="email" id="loginEmail" placeholder="E-Mail">
                <input type="password" id="loginPassword" placeholder="Passwort">
                <button id="loginButton">Anmelden</button>
                <p>Noch kein Konto? <a href="#" id="showRegister">Jetzt registrieren</a></p>
                <p id="authError" style="color: red;"></p>
            </div>
            <div id="registerForm" style="display: none;">
                <h2>Registrieren</h2>
                <input type="email" id="registerEmail" placeholder="E-Mail">
                <input type="password" id="registerPassword" placeholder="Passwort">
                <button id="registerButton">Registrieren</button>
                <p>Bereits ein Konto? <a href="#" id="showLogin">Zurück zur Anmeldung</a></p>
                <p id="registerError" style="color: red;"></p>
            </div>

            <hr style="width: 80%; border: 1px solid #ddd; margin: 20px 0;">

            <button id="googleLoginButton">
                <svg viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M44.5 20H24V28H35.5C34.7 32.7 30.6 35.5 24 35.5C18.6 35.5 13.9 31.8 11.9 26.5C11.3 25.1 11 23.6 11 22C11 20.4 11.3 18.9 11.9 17.5C13.9 12.2 18.6 8.5 24 8.5C28.2 8.5 31.7 10.1 34.3 12.7L39.1 7.9C35.2 4.1 29.8 2 24 2C13.8 2 5.5 9.7 2.7 20H44.5V20Z" fill="#F4B400"/>
                    <path d="M24 35.5C30.6 35.5 34.7 32.7 35.5 28H24V35.5Z" fill="#DB4437"/>
                    <path d="M11.9 26.5C11.3 25.1 11 23.6 11 22C11 20.4 11.3 18.9 11.9 17.5C13.9 12.2 18.6 8.5 24 8.5C28.2 8.5 31.7 10.1 34.3 12.7L39.1 7.9C35.2 4.1 29.8 2 24 2C13.8 2 5.5 9.7 2.7 20L11.9 26.5Z" fill="#4285F4"/>
                    <path d="M2.7 20C2.1 21.3 2 22.7 2 24C2 25.3 2.1 26.7 2.7 28L11.9 21.5L2.7 20Z" fill="#0F9D58"/>
                </svg>
                Mit Google anmelden
            </button>
        </div>
    </div>

    <div class="game-container" id="gameContainer" style="display: none;">
        <div id="userInfo"></div>
        <div class="level-info" id="level-info">Level 1</div>
        <canvas id="gameCanvas"></canvas>
        <div class="ui-panel">
            <div class="stats-container">
                <div class="stat-item">
                    Lungenkapazität<br>
                    <span id="lungen-kapazitaet-text">100%</span>
                    <div class="progress-bar">
                        <div class="progress-bar-fill" id="lungen-kapazitaet-bar"></div>
                    </div>
                </div>
                <div class="stat-item">
                    Stiele gesammelt<br>
                    <span id="stiele-counter">0 / 5</span>
                </div>
            </div>
            <div class="info-message" id="info-message">Bewegen Sie sich mit den Pfeiltasten oder WASD. Sammeln Sie alle Stiele, um das Level zu beenden.</div>
            <div style="display: flex; gap: 10px;">
                <button class="button" id="openDialogueButton">✨ Lass uns reden!</button>
                <button class="button" id="openLevelSelectButton">Level-Auswahl</button>
                <button class="button" id="logoutButton">Abmelden</button>
            </div>
        </div>

        <!-- Player List / Leaderboard -->
        <div class="player-list">
            <h3>Mitspieler</h3>
            <div id="player-list-container"></div>
        </div>
    </div>
    
    <div class="overlay" id="overlay">
        <span id="overlay-text"></span>
    </div>

    <!-- Dialogue UI -->
    <div class="dialogue-overlay" id="dialogueOverlay">
        <div class="dialogue-box">
            <button class="dialogue-close-button" id="closeDialogueButton">&times;</button>
            <div class="dialogue-title">Herr Winkelmann sagt...</div>
            <div class="dialogue-text" id="dialogueText">Fragen Sie mich alles, aber bitte nicht, wie viele Stiele ich noch brauche... Bin schon ganz aus der Puste!</div>
            <div class="dialogue-input-container">
                <input type="text" id="dialogueInput" class="dialogue-input" placeholder="Stellen Sie eine Frage...">
                <button class="dialogue-button" id="sendDialogueButton">Senden</button>
            </div>
        </div>
    </div>

    <!-- Level Select UI -->
    <div class="level-select-overlay" id="levelSelectOverlay">
        <div class="level-select-container">
            <div class="dialogue-title">Wähle ein Level</div>
            <div class="level-select-grid" id="levelSelectGrid"></div>
            <button class="button" style="margin-top: 20px;" id="closeLevelSelectButton">Schließen</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithCustomToken, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, GoogleAuthProvider, signInWithPopup } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, collection, onSnapshot, runTransaction, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase-Konfiguration aus der Umgebung
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        let app, db, auth;
        let highestLevel = 1;
        let userId;

        // UI element references
        const authContainer = document.getElementById('authContainer');
        const authForms = document.getElementById('authForms');
        const loadingMessage = document.getElementById('loadingMessage');
        const gameContainer = document.getElementById('gameContainer');
        const loginForm = document.getElementById('loginForm');
        const registerForm = document.getElementById('registerForm');
        const showRegisterLink = document.getElementById('showRegister');
        const showLoginLink = document.getElementById('showLogin');
        const loginEmailInput = document.getElementById('loginEmail');
        const loginPasswordInput = document.getElementById('loginPassword');
        const loginButton = document.getElementById('loginButton');
        const registerEmailInput = document.getElementById('registerEmail');
        const registerPasswordInput = document.getElementById('registerPassword');
        const registerButton = document.getElementById('registerButton');
        const authError = document.getElementById('authError');
        const registerError = document.getElementById('registerError');
        const userInfoDisplay = document.getElementById('userInfo');
        const logoutButton = document.getElementById('logoutButton');
        const googleLoginButton = document.getElementById('googleLoginButton');
        const playerListContainer = document.getElementById('player-list-container');
        
        // Multiplayer-spezifische Variablen
        const GAME_SESSION_ID = 'mainMultiplayerSession';
        let isMultiplayerActive = false;
        let otherPlayers = {};
        let localPlayerState = {};

        // Hauptanwendungsfluss, aufrufbar nach der Firebase-Initialisierung
        async function startAppFlow() {
            if (!auth || !db) {
                console.error("Firebase not initialized. Cannot start app flow.");
                loadingMessage.textContent = "Fehler: Firebase-Konfiguration ungültig. Bitte überprüfen Sie Ihre Daten.";
                return;
            }

            // Authentication Event Listeners
            showRegisterLink.addEventListener('click', (e) => {
                e.preventDefault();
                loginForm.style.display = 'none';
                registerForm.style.display = 'block';
                authError.textContent = '';
            });

            showLoginLink.addEventListener('click', (e) => {
                e.preventDefault();
                loginForm.style.display = 'block';
                registerForm.style.display = 'none';
                registerError.textContent = '';
            });

            loginButton.addEventListener('click', async () => {
                const email = loginEmailInput.value;
                const password = loginPasswordInput.value;
                authError.textContent = '';
                try {
                    await signInWithEmailAndPassword(auth, email, password);
                } catch (error) {
                    authError.textContent = 'Login fehlgeschlagen. Bitte überprüfen Sie E-Mail und Passwort.';
                    console.error("Login failed:", error);
                }
            });

            registerButton.addEventListener('click', async () => {
                const email = registerEmailInput.value;
                const password = registerPasswordInput.value;
                registerError.textContent = '';
                try {
                    await createUserWithEmailAndPassword(auth, email, password);
                } catch (error) {
                    if (error.code === 'auth/email-already-in-use') {
                        registerError.textContent = 'Diese E-Mail-Adresse wird bereits verwendet.';
                    } else {
                        registerError.textContent = 'Registrierung fehlgeschlagen. Bitte versuchen Sie es erneut.';
                    }
                    console.error("Registration failed:", error);
                }
            });

            googleLoginButton.addEventListener('click', async () => {
                const provider = new GoogleAuthProvider();
                authError.textContent = '';
                try {
                    await signInWithPopup(auth, provider);
                } catch (error) {
                    authError.textContent = 'Anmeldung mit Google fehlgeschlagen.';
                    console.error("Google login failed:", error);
                }
            });

            logoutButton.addEventListener('click', async () => {
                try {
                    await signOut(auth);
                } catch (error) {
                    console.error("Logout failed:", error);
                }
            });
            
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    userInfoDisplay.textContent = `Angemeldet als: ${user.email || 'Anonym'}`;
                    authContainer.style.display = 'none';
                    gameContainer.style.display = 'flex';
                    
                    const userDocRef = doc(db, 'artifacts', appId, 'users', userId, 'gameData', 'progress');
                    try {
                        const docSnap = await getDoc(userDocRef);
                        if (docSnap.exists()) {
                            highestLevel = docSnap.data().highestLevel;
                            console.log("Progress loaded from Firestore. Highest level:", highestLevel);
                        } else {
                            await setDoc(userDocRef, { highestLevel: 1 });
                            console.log("New progress document created.");
                        }
                    } catch (error) {
                        console.error("Error fetching or creating user data:", error);
                    }

                    initializeGame();
                    
                } else {
                    userInfoDisplay.textContent = '';
                    authContainer.style.display = 'flex';
                    gameContainer.style.display = 'none';
                    isMultiplayerActive = false;
                    console.log("User logged out.");
                    loadingMessage.style.display = 'none';
                    authForms.style.display = 'block';
                }
            });

            // Erster Anmeldeversuch mit dem bereitgestellten Token
            if (initialAuthToken) {
                try {
                    await signInWithCustomToken(auth, initialAuthToken);
                } catch (e) {
                    console.error("Anmeldung mit benutzerdefiniertem Token fehlgeschlagen:", e);
                    loadingMessage.style.display = 'none';
                    authForms.style.display = 'block';
                }
            } else {
                 loadingMessage.style.display = 'none';
                 authForms.style.display = 'block';
            }
        }

        async function initializeGame() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const overlay = document.getElementById('overlay');
            const overlayText = document.getElementById('overlay-text');
            const lungenKapazitaetBar = document.getElementById('lungen-kapazitaet-bar');
            const lungenKapazitaetText = document.getElementById('lungen-kapazitaet-text');
            const stieleCounterText = document.getElementById('stiele-counter');
            const infoMessage = document.getElementById('info-message');
            const levelInfo = document.getElementById('level-info');
            
            const openDialogueButton = document.getElementById('openDialogueButton');
            const dialogueOverlay = document.getElementById('dialogueOverlay');
            const dialogueText = document.getElementById('dialogueText');
            const dialogueInput = document.getElementById('dialogueInput');
            const sendDialogueButton = document.getElementById('sendDialogueButton');
            const closeDialogueButton = document.getElementById('closeDialogueButton');
            const openLevelSelectButton = document.getElementById('openLevelSelectButton');
            const levelSelectOverlay = document.getElementById('levelSelectOverlay');
            const levelSelectGrid = document.getElementById('levelSelectGrid');
            const closeLevelSelectButton = document.getElementById('closeLevelSelectButton');

            let animationFrameId;
            let lastTime = 0;
            let keys = {};
            let isRunning = false;
            let gameData = { level: 1 };
            let isSpeaking = false;
            let lowLungsWarning = false;
            
            const playerColors = ['#ff7e5f', '#4CAF50', '#4285F4', '#F4B400', '#DB4437', '#0F9D58'];
            let playerColor = playerColors[Math.floor(Math.random() * playerColors.length)];

            const baseSpeed = 250;
            const maxLungenKapazitaet = 100;
            const TOTAL_LEVELS = 50;
            const INITIAL_OBSTACLES = 1;
            const STIELE_PER_LEVEL = 10;

            const playersCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'games', GAME_SESSION_ID, 'players');
            const stieleCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'games', GAME_SESSION_ID, 'stiele');
            const gameDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', GAME_SESSION_ID);
            
            // Spielerstatus in Firestore aktualisieren
            async function updateLocalPlayerState() {
                if (!isMultiplayerActive || !userId) return;
                try {
                    await setDoc(doc(playersCollectionRef, userId), {
                        x: localPlayerState.x,
                        y: localPlayerState.y,
                        stiele: localPlayerState.stiele,
                        email: auth.currentUser.email || 'Anonym',
                        color: playerColor,
                        lastActive: new Date(),
                    }, { merge: true });
                } catch (e) {
                    console.error("Fehler beim Aktualisieren des Spielerstatus:", e);
                }
            }

            // Echtzeit-Listener für alle Spieler
            onSnapshot(playersCollectionRef, (snapshot) => {
                snapshot.docChanges().forEach(change => {
                    const playerData = change.doc.data();
                    const playerId = change.doc.id;

                    if (playerId === userId) {
                        return; // Lokalen Spieler überspringen
                    }

                    if (change.type === 'removed') {
                        delete otherPlayers[playerId];
                    } else {
                        otherPlayers[playerId] = {
                            x: playerData.x,
                            y: playerData.y,
                            stiele: playerData.stiele,
                            email: playerData.email,
                            color: playerData.color
                        };
                    }
                });
                updatePlayerListUI();
            });

            // Echtzeit-Listener für Stiele
            onSnapshot(stieleCollectionRef, (snapshot) => {
                gameData.stiele = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            });
            
            async function resetGameSession() {
                // Entferne alte Stiele und Spieler
                const oldStiele = await getDocs(stieleCollectionRef);
                oldStiele.forEach(doc => deleteDoc(doc.ref));

                const oldPlayers = await getDocs(playersCollectionRef);
                oldPlayers.forEach(doc => deleteDoc(doc.ref));
                
                // Setze globale Spielvariablen zurück
                await setDoc(gameDocRef, { requiredStiele: STIELE_PER_LEVEL, currentStiele: 0, winner: null });

                // Erzeuge neue Stiele
                generateStiele(STIELE_PER_LEVEL);
            }

            // Funktion zur Generierung von Stielen
            async function generateStiele(count) {
                for (let i = 0; i < count; i++) {
                    const pos = getNonOverlappingPosition([], 15, 15);
                    await addDoc(stieleCollectionRef, { x: pos.x, y: pos.y, width: 15, height: 15, color: '#ff7e5f' });
                }
            }
            
            async function getNonOverlappingPosition(existingObjects, width, height) {
                let newPos, overlapping;
                do {
                    overlapping = false;
                    newPos = {
                        x: Math.random() * (canvas.width - width),
                        y: Math.random() * (canvas.height - height),
                        width: width,
                        height: height
                    };
                    
                    for (const obj of existingObjects) {
                        if (checkCollision(obj, newPos)) {
                            overlapping = true;
                            break;
                        }
                    }
                } while (overlapping);
                return newPos;
            }

            // --- Gemini TTS API Integration ---
            const TTS_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=";
            const API_KEY = "";

            async function speak(text, voiceName = "Kore") {
                if (isSpeaking) return;
                isSpeaking = true;
                
                try {
                    const payload = {
                        contents: [{ parts: [{ text }] }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName }
                                }
                            }
                        },
                        model: "gemini-2.5-flash-preview-tts"
                    };

                    const response = await fetch(TTS_API_URL + API_KEY, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`API error: ${response.statusText}`);
                    }

                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        const audioUrl = URL.createObjectURL(wavBlob);

                        const audio = new Audio(audioUrl);
                        audio.play();
                        audio.onended = () => {
                            URL.revokeObjectURL(audioUrl);
                            isSpeaking = false;
                        };
                    } else {
                        throw new Error("Invalid audio data from API");
                    }
                } catch (error) {
                    console.error("Failed to generate speech:", error);
                    isSpeaking = false;
                }
            }

            function base64ToArrayBuffer(base64) {
                const binaryString = window.atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }

            function pcmToWav(pcmData, sampleRate) {
                const numChannels = 1;
                const bytesPerSample = 2;
                const blockAlign = numChannels * bytesPerSample;
                const byteRate = sampleRate * blockAlign;

                const wavHeader = new ArrayBuffer(44);
                const view = new DataView(wavHeader);

                // RIFF chunk
                writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + pcmData.byteLength, true); // ChunkSize
                writeString(view, 8, 'WAVE');

                // fmt chunk
                writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true); // Subchunk1Size
                view.setUint16(20, 1, true); // AudioFormat (1=PCM)
                view.setUint16(22, numChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, byteRate, true);
                view.setUint16(32, blockAlign, true);
                view.setUint16(34, 16, true); // BitsPerSample

                // data chunk
                writeString(view, 36, 'data');
                view.setUint32(40, pcmData.byteLength, true);

                const blob = new Blob([wavHeader, pcmData], { type: 'audio/wav' });
                return blob;
            }

            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }
            // --- End of Gemini TTS API Integration ---

            // --- Gemini LLM Dialogue Integration ---
            const LLM_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=";
            const systemPrompt = `Du bist Herr Winkelmann, ein sehr höflicher, leicht außer Atem geratener Mann, der damit beschäftigt ist, Stiele einzusammeln. Antworte immer kurz, freundlich und in der Ich-Form. Deine Antworten sollten widerspiegeln, dass du dich gerade anstrengst, aber fest entschlossen bist. Beziehe dich auf deine aktuelle Aufgabe, wenn es passt. Du bist ein einfacher Mann. Vermeide übermäßig komplexe Sprache.`;
            let isGeneratingResponse = false;

            async function generateAndSpeakResponse(userQuery) {
                if (isGeneratingResponse) return;
                isGeneratingResponse = true;
                sendDialogueButton.disabled = true;
                dialogueInput.disabled = true;
                dialogueText.textContent = "Herr Winkelmann denkt nach...";

                try {
                    const payload = {
                        contents: [{ parts: [{ text: userQuery }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                    };

                    const response = await fetch(LLM_API_URL + API_KEY, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`API error: ${response.statusText}`);
                    }

                    const result = await response.json();
                    const text = result?.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (text) {
                        dialogueText.textContent = text;
                        await speak(text, "Leda");
                    } else {
                        throw new Error("Invalid response from LLM API");
                    }
                } catch (error) {
                    console.error("Failed to generate dialogue:", error);
                    dialogueText.textContent = "Huch, etwas ist schiefgelaufen. Ich kann jetzt nicht reden.";
                } finally {
                    isGeneratingResponse = false;
                    sendDialogueButton.disabled = false;
                    dialogueInput.disabled = false;
                }
            }
            // --- End of Gemini LLM Dialogue Integration ---
            
            function resizeCanvas() {
                canvas.width = window.innerWidth * 0.7;
                canvas.height = window.innerHeight * 0.7;
                if (canvas.width > 800) canvas.width = 800;
                if (canvas.height > 600) canvas.height = 600;
                resetGame();
            }

            async function resetGame() {
                cancelAnimationFrame(animationFrameId);
                isRunning = false;
                
                // Setze den lokalen Spielerstatus zurück
                localPlayerState = {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    width: 30,
                    height: 30,
                    speed: baseSpeed,
                    stiele: 0,
                    lungenKapazitaet: maxLungenKapazitaet
                };
                
                gameData = {
                    stiele: [],
                    obstacles: [],
                    requiredStiele: STIELE_PER_LEVEL,
                };
                
                // Wenn wir der erste Spieler in der Session sind, setzen wir das Spiel zurück
                const gameSnap = await getDoc(gameDocRef);
                if (!gameSnap.exists() || gameSnap.data().requiredStiele === undefined) {
                     await resetGameSession();
                } else {
                    gameData.requiredStiele = gameSnap.data().requiredStiele;
                }

                draw();
                updateUI();
                showOverlay("Willkommen! Sammle die Stiele!", false);
            }
            
            async function startGame() {
                 overlay.classList.remove('active');
                 if (!isRunning) {
                     isRunning = true;
                     isMultiplayerActive = true;
                     lastTime = performance.now();
                     animationFrameId = requestAnimationFrame(gameLoop);
                     infoMessage.textContent = "Sammle die Stiele, bevor die Lungenkapazität aufgebraucht ist!";
                     speak("Los geht's! Nur nicht schlapp machen!", "Puck");
                 }
             }

            function gameLoop(time) {
                const deltaTime = (time - lastTime) / 1000;
                lastTime = time;

                if (isRunning) {
                    update(deltaTime);
                    draw();
                    animationFrameId = requestAnimationFrame(gameLoop);
                }
            }

            function update(deltaTime) {
                // Update local player state based on input
                const speed = baseSpeed;
                let dx = 0;
                let dy = 0;
                if (keys['arrowup'] || keys['w']) dy = -1;
                if (keys['arrowdown'] || keys['s']) dy = 1;
                if (keys['arrowleft'] || keys['a']) dx = -1;
                if (keys['arrowright'] || keys['d']) dx = 1;

                if (dx !== 0 || dy !== 0) {
                    const length = Math.sqrt(dx * dx + dy * dy);
                    if (length > 0) {
                        localPlayerState.x += (dx / length) * speed * deltaTime;
                        localPlayerState.y += (dy / length) * speed * deltaTime;
                    }
                }

                // Boundary Check
                localPlayerState.x = Math.max(0, Math.min(canvas.width - localPlayerState.width, localPlayerState.x));
                localPlayerState.y = Math.max(0, Math.min(canvas.height - localPlayerState.height, localPlayerState.y));

                // Lungenkapazitäts-Drain
                localPlayerState.lungenKapazitaet -= 1 * deltaTime;
                if (localPlayerState.lungenKapazitaet <= 0) {
                    endLevel(false, "Da gibt's nichts mehr...");
                    return;
                }
                
                if (localPlayerState.lungenKapazitaet < 20 && !lowLungsWarning) {
                    speak("Uff... die Luft wird knapp!", "Orus");
                    lowLungsWarning = true;
                } else if (localPlayerState.lungenKapazitaet > 20) {
                    lowLungsWarning = false;
                }
                
                // Kollisionserkennung und Stiele-Aufnahme
                gameData.stiele.forEach(stiel => {
                    if (checkCollision(localPlayerState, stiel)) {
                        // Sammle den Stiel nur lokal, bis die Transaktion abgeschlossen ist
                        // Die onSnapshot wird die Ansicht synchronisieren
                        try {
                            // Transaktion, um Rennbedingungen zu vermeiden
                            runTransaction(db, async (transaction) => {
                                const stielRef = doc(stieleCollectionRef, stiel.id);
                                const stielDoc = await transaction.get(stielRef);
                                
                                if (stielDoc.exists()) {
                                    // Entferne den Stiel aus der Datenbank
                                    transaction.delete(stielRef);
                                    
                                    // Erhöhe den Zähler für diesen Spieler
                                    localPlayerState.stiele++;
                                    localPlayerState.lungenKapazitaet = Math.min(maxLungenKapazitaet, localPlayerState.lungenKapazitaet + 10);
                                    
                                    // Aktualisiere den Spielerstatus in der Datenbank
                                    const playerRef = doc(playersCollectionRef, userId);
                                    transaction.set(playerRef, { stiele: localPlayerState.stiele, lungenKapazitaet: localPlayerState.lungenKapazitaet }, { merge: true });

                                    // Überprüfe, ob das Spiel beendet ist
                                    const gameRef = doc(gameDocRef,);
                                    const gameDoc = await transaction.get(gameRef);
                                    
                                    const currentStieleCount = gameDoc.data().currentStiele || 0;
                                    const updatedCount = currentStieleCount + 1;
                                    
                                    if (updatedCount >= gameData.requiredStiele && !gameDoc.data().winner) {
                                        transaction.update(gameRef, { winner: userId, currentStiele: updatedCount });
                                    } else {
                                        transaction.update(gameRef, { currentStiele: updatedCount });
                                    }
                                }
                            });
                        } catch (e) {
                            console.error("Transaktion fehlgeschlagen: ", e);
                        }
                    }
                });

                // Sende lokalen Status an Firebase
                updateLocalPlayerState();

                updateUI();
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Zeichne Stiele
                gameData.stiele.forEach(stiel => {
                    ctx.beginPath();
                    ctx.arc(stiel.x + stiel.width / 2, stiel.y + stiel.height / 2, stiel.width / 2, 0, 2 * Math.PI);
                    ctx.fillStyle = '#ff7e5f';
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
                
                // Zeichne andere Spieler
                for (const playerId in otherPlayers) {
                    const player = otherPlayers[playerId];
                    ctx.fillStyle = player.color;
                    ctx.fillRect(player.x, player.y, localPlayerState.width, localPlayerState.height);
                    
                    ctx.fillStyle = 'black';
                    ctx.font = '12px Roboto Mono';
                    ctx.textAlign = 'center';
                    ctx.fillText(player.email.split('@')[0], player.x + localPlayerState.width / 2, player.y - 5);
                }

                // Zeichne den lokalen Spieler
                ctx.fillStyle = playerColor;
                ctx.fillRect(localPlayerState.x, localPlayerState.y, localPlayerState.width, localPlayerState.height);

                ctx.fillStyle = 'black';
                ctx.font = '12px Roboto Mono';
                ctx.textAlign = 'center';
                ctx.fillText('Sie', localPlayerState.x + localPlayerState.width / 2, localPlayerState.y - 5);
            }

            function updateUI() {
                const lungenProzent = Math.max(0, (localPlayerState.lungenKapazitaet / maxLungenKapazitaet) * 100);
                lungenKapazitaetBar.style.width = `${lungenProzent}%`;
                lungenKapazitaetText.textContent = `${Math.floor(lungenProzent)}%`;

                const lungenColor = lungenProzent > 50 ? '#4CAF50' : (lungenProzent > 20 ? '#FFC107' : '#F4436');
                lungenKapazitaetBar.style.background = `linear-gradient(90deg, ${lungenColor}, ${lungenProzent > 50 ? '#8bc34a' : (lungenProzent > 20 ? '#ffeb3b' : '#ff7979')})`;
                
                stieleCounterText.textContent = `${localPlayerState.stiele} / ${gameData.requiredStiele}`;
                levelInfo.textContent = `Spiel läuft`;
                
                // Update player list UI
                updatePlayerListUI();
            }
            
            function updatePlayerListUI() {
                const allPlayers = {
                    ...otherPlayers,
                    [userId]: {
                        email: auth.currentUser.email || 'Anonym',
                        stiele: localPlayerState.stiele,
                        color: playerColor,
                    }
                };
                
                const sortedPlayers = Object.entries(allPlayers).sort(([, a], [, b]) => b.stiele - a.stiele);
                
                playerListContainer.innerHTML = '';
                sortedPlayers.forEach(([id, player]) => {
                    const isCurrentUser = id === userId;
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'player-item' + (isCurrentUser ? ' current' : '');
                    playerDiv.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div style="width: 10px; height: 10px; border-radius: 50%; background-color: ${player.color};"></div>
                            <span>${player.email.split('@')[0]}</span>
                        </div>
                        <span>${player.stiele} Stiele</span>
                    `;
                    playerListContainer.appendChild(playerDiv);
                });
            }


            function showOverlay(text, isWin) {
                overlayText.textContent = text;
                overlay.style.backgroundColor = isWin ? 'rgba(76, 175, 80, 0.7)' : 'rgba(255, 0, 0, 0.7)';
                overlay.classList.add('active');
            }

            async function endLevel(isWin, message, winnerId = null) {
                isRunning = false;
                isMultiplayerActive = false;
                cancelAnimationFrame(animationFrameId);
                
                if (isWin) {
                    const winnerEmail = otherPlayers[winnerId]?.email || auth.currentUser.email || 'Anonym';
                    const winnerName = winnerEmail.split('@')[0];
                    showOverlay(`${winnerName} hat gewonnen!`, true);
                    speak("Das war eine Meisterleistung!", "Zephyr");
                } else {
                    showOverlay(message, false);
                    speak("Da gibt's nichts mehr...", "Charon");
                }
                
                // Cleanup after a delay
                setTimeout(async () => {
                     // Wenn die Transaktion den Sieger nicht setzt, kann der Verlierer das Spiel neu starten.
                     // Wenn Sieger gesetzt ist, sollte nur der Sieger das Spiel neu starten.
                     const gameDocSnap = await getDoc(gameDocRef);
                     if (gameDocSnap.data()?.winner === userId) {
                         await resetGameSession();
                         startGame();
                     }
                }, 3000);
            }

            function checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            // Event-Listener
            document.addEventListener('keydown', (e) => {
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd'].includes(e.key.toLowerCase())) {
                    keys[e.key.toLowerCase()] = true;
                    if (!isRunning && overlay.classList.contains('active')) {
                         startGame();
                    }
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            openDialogueButton.addEventListener('click', () => {
                if (isRunning) {
                     isRunning = false;
                     cancelAnimationFrame(animationFrameId);
                }
                dialogueOverlay.style.display = 'flex';
            });
            closeDialogueButton.addEventListener('click', () => {
                dialogueOverlay.style.display = 'none';
                if (!isRunning) {
                    startGame();
                }
            });
            sendDialogueButton.addEventListener('click', () => {
                const userQuery = dialogueInput.value.trim();
                if (userQuery) {
                    generateAndSpeakResponse(userQuery);
                    dialogueInput.value = '';
                }
            });
            dialogueInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    sendDialogueButton.click();
                }
            });
            
            // Level-Auswahl ist im Multiplayer-Modus deaktiviert
            openLevelSelectButton.style.display = 'none';
            closeLevelSelectButton.style.display = 'none';

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Setze einen Listener für den Spielstand, um den Sieger zu bestimmen
            onSnapshot(gameDocRef, (doc) => {
                const data = doc.data();
                if (data && data.winner) {
                    endLevel(true, `${data.winner} hat gewonnen!`, data.winner);
                }
            });

            // Setze das Spiel beim ersten Laden zurück und starte es
            resetGame();
            startGame();
        }
        
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            console.log("Firebase initialized successfully.");
            startAppFlow();
        } catch (e) {
            console.error("Firebase initialization failed. Please check the provided firebaseConfig.", e);
            loadingMessage.textContent = "Fehler: Verbindung zur Datenbank fehlgeschlagen. Bitte versuchen Sie es später erneut.";
            loadingMessage.style.color = "red";
            loadingMessage.style.fontSize = "1.2em";
            loadingMessage.style.fontWeight = "bold";
        }
    </script>
</body>
</html>
