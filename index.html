<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Herr Winkelmann</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --primary: #8a2be2;
            --secondary: #9370db;
            --background: #f0eafb;
            --surface: #ffffff;
            --text: #333333;
            --success: #4CAF50;
            --danger: #ef4444;
            --accent: #ffa500;
        }

        body {
            font-family: 'Inter', sans-serif;
            color: var(--text);
            background-color: var(--background);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            transition: background-color 0.5s ease-in-out;
            user-select: none;
        }

        .screen-container {
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 90%;
            max-width: 450px;
        }
        
        .screen-container.active {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }

        .auth-container, .mode-select-container, .multiplayer-container, .lobby-container {
            background-color: var(--surface);
            padding: 2.5rem;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 100%;
        }

        .game-container {
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 1.5rem;
            background-color: var(--surface);
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 900px;
        }

        h2 {
            font-size: 2rem;
            font-weight: 800;
            margin-bottom: 1rem;
            color: var(--primary);
        }
        
        .form-input {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.5rem;
            background-color: #f9fafb;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .form-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(138, 43, 226, 0.2);
        }
        
        .btn {
            width: 100%;
            padding: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            border: none;
            border-radius: 0.5rem;
            color: white;
            background: linear-gradient(145deg, var(--secondary), var(--primary));
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
        }
        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
        }

        .btn-link {
            color: var(--primary);
            text-decoration: none;
            font-weight: 600;
            transition: color 0.2s;
        }
        .btn-link:hover {
            color: var(--secondary);
        }
        
        .message-box {
            background-color: #ffe4e4;
            color: #cc0000;
            border: 1px solid #ff9999;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }
        
        canvas {
            background-color: #a4d3ff;
            border-radius: 0.75rem;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.2);
            touch-action: none;
            width: 100%;
            height: auto;
            aspect-ratio: 4 / 3;
        }

        .ui-panel {
            width: 100%;
            padding: 1rem;
            background-color: #f9fafb;
            border-radius: 0.75rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            margin-top: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            align-items: center;
        }
        
        .stat-item {
            text-align: center;
            font-size: 1rem;
            font-weight: 600;
        }
        
        .progress-bar {
            height: 1.25rem;
            background-color: #e5e7eb;
            border-radius: 9999px;
            overflow: hidden;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .progress-bar-fill {
            height: 100%;
            transition: width 0.5s ease-out;
            border-radius: 9999px;
        }
        
        .info-message {
            text-align: center;
            font-style: italic;
            font-weight: 400;
        }
        
        .dialogue-overlay, .level-select-overlay, .game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s;
        }
        
        .dialogue-overlay.active, .level-select-overlay.active, .game-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .dialogue-box, .level-select-box {
            background-color: var(--surface);
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 500px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .level-select-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(6rem, 1fr));
            gap: 0.75rem;
            margin-top: 1rem;
            max-height: 50vh;
            overflow-y: auto;
        }
        
        .level-button {
            padding: 1rem;
            font-weight: 600;
            background-color: #f3f4f6;
            border: 2px solid #e5e7eb;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            position: relative;
        }
        .level-button:hover:not(:disabled) {
            background-color: #e5e7eb;
            border-color: var(--primary);
        }
        .level-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background-color: #d1d5db;
        }

        .lobby-container p {
            font-size: 1.125rem;
            margin-bottom: 1.5rem;
            font-weight: 600;
        }
        
        .player-list {
            margin-top: 1rem;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            padding: 0.5rem;
        }

        .player-list-item {
            padding: 0.5rem;
            background-color: #f9fafb;
            border-radius: 0.375rem;
            margin-bottom: 0.25rem;
            font-weight: 400;
            word-wrap: break-word;
        }
    </style>
</head>
<body class="bg-background">
    <div id="authContainer" class="screen-container active">
        <div id="loadingMessage" class="text-xl font-bold">Lade Spiel...</div>
        <div id="authForms" style="display: none;">
            <div id="loginForm">
                <h2>Anmelden</h2>
                <input type="email" id="loginEmail" placeholder="E-Mail" class="form-input">
                <input type="password" id="loginPassword" placeholder="Passwort" class="form-input">
                <button id="loginButton" class="btn">Anmelden</button>
                <p class="mt-4 text-sm">Noch kein Konto? <a href="#" id="showRegister" class="btn-link">Jetzt registrieren</a></p>
                <div id="authError" class="message-box" style="display: none;"></div>
            </div>
            <div id="registerForm" style="display: none;">
                <h2>Registrieren</h2>
                <input type="email" id="registerEmail" placeholder="E-Mail" class="form-input">
                <input type="password" id="registerPassword" placeholder="Passwort" class="form-input">
                <button id="registerButton" class="btn">Registrieren</button>
                <p class="mt-4 text-sm">Bereits ein Konto? <a href="#" id="showLogin" class="btn-link">Zurück zur Anmeldung</a></p>
                <div id="registerError" class="message-box" style="display: none;"></div>
            </div>
        </div>
    </div>
    
    <div id="modeSelectContainer" class="screen-container">
        <div class="mode-select-container">
            <h2 class="mb-4">Wählen Sie einen Modus</h2>
            <p id="modeSelectInfo" class="text-gray-600 mb-6"></p>
            <button id="singlePlayerButton" class="btn mb-4">Einzelspieler</button>
            <button id="multiplayerButton" class="btn mb-4">Mehrspieler</button>
            <button id="logoutButton" class="btn bg-gray-400 hover:bg-gray-500">Abmelden</button>
        </div>
    </div>

    <div id="multiplayerContainer" class="screen-container">
        <div class="multiplayer-container">
            <h2 class="mb-4">Mehrspieler-Modus</h2>
            <p class="text-gray-600 mb-6">Tragen Sie einen Lobby-Code ein oder erstellen Sie eine neue Lobby.</p>
            <input type="text" id="joinLobbyCode" placeholder="Lobby-Code eingeben" class="form-input text-center uppercase tracking-widest font-bold">
            <button id="joinLobbyButton" class="btn mb-4">Beitreten</button>
            <p class="my-4 font-bold text-gray-400">ODER</p>
            <button id="createLobbyButton" class="btn">Lobby erstellen</button>
            <div id="multiplayerMessage" class="message-box" style="display: none;"></div>
            <button id="multiplayerBackButton" class="btn mt-6 bg-gray-400 hover:bg-gray-500">Zurück</button>
        </div>
    </div>

    <div id="lobbyContainer" class="screen-container">
        <div class="lobby-container">
            <h2 id="lobbyTitle" class="mb-2"></h2>
            <p class="text-sm text-gray-500">Lobby-Code zum Teilen:</p>
            <p id="lobbyCodeDisplay" class="text-3xl font-extrabold tracking-widest text-primary mb-4"></p>
            <p class="text-gray-600 mb-2">Warten auf andere Spieler...</p>
            <div class="player-list" id="playerList"></div>
            <div id="lobbyStatusMessage" class="message-box text-sm text-success" style="display: none; background-color: #e8f5e9;"></div>
            <button id="startGameButton" class="btn mt-6" style="display: none;">Spiel starten</button>
            <button id="leaveLobbyButton" class="btn mt-2 bg-red-400 hover:bg-red-500">Lobby verlassen</button>
        </div>
    </div>

    <div id="gameContainer" class="game-container">
        <div id="userInfo" class="text-sm text-gray-500 mb-2"></div>
        <canvas id="gameCanvas" class="w-full h-auto aspect-w-4 aspect-h-3"></canvas>
        <div class="ui-panel">
            <div class="flex justify-around w-full gap-4">
                <div class="stat-item flex-1">
                    Lungenkapazität<br>
                    <span id="lungen-kapazitaet-text" class="font-extrabold text-lg">100%</span>
                    <div class="progress-bar w-full mt-1">
                        <div class="progress-bar-fill h-full bg-green-500" id="lungen-kapazitaet-bar"></div>
                    </div>
                </div>
                <div class="stat-item flex-1">
                    Stiele gesammelt<br>
                    <span id="stiele-counter" class="font-extrabold text-lg">0 / 5</span>
                </div>
                <div class="stat-item flex-1" id="multiplayerTimerDisplay" style="display: none;">
                    Zeit verbleibend<br>
                    <span id="gameTimer" class="font-extrabold text-lg">3:00</span>
                </div>
            </div>
            <div class="info-message text-sm text-gray-500">Bewegen Sie sich mit den Pfeiltasten oder WASD. Sammeln Sie alle Stiele, um das Level zu beenden.</div>
            <div class="flex flex-col sm:flex-row gap-2 mt-2 w-full max-w-sm">
                <button class="btn" id="openDialogueButton">Lass uns reden!</button>
                <button class="btn" id="openLevelSelectButton">Level-Auswahl</button>
            </div>
            <button id="returnToModeSelectButton" class="btn mt-2 w-full max-w-sm bg-gray-400 hover:bg-gray-500" style="display: none;">Modus wechseln</button>
        </div>
    </div>
    
    <div id="gameOverlay" class="game-overlay">
        <div class="bg-white p-8 rounded-xl shadow-2xl text-center flex flex-col items-center">
            <h3 id="overlay-text" class="text-3xl font-extrabold mb-4"></h3>
            <button id="overlay-close-button" class="btn mt-4">OK</button>
        </div>
    </div>

    <!-- Dialogue UI -->
    <div id="dialogueOverlay" class="dialogue-overlay">
        <div class="dialogue-box">
            <div class="flex justify-between items-center">
                <div class="dialogue-title">Herr Winkelmann sagt...</div>
                <button id="closeDialogueButton" class="text-2xl font-bold text-gray-500">&times;</button>
            </div>
            <div id="dialogueText" class="dialogue-text bg-gray-50 p-4 rounded-lg text-left text-sm border border-gray-200">
                Fragen Sie mich alles, aber bitte nicht, wie viele Stiele ich noch brauche... Bin schon ganz aus der Puste!
            </div>
            <div class="flex gap-2">
                <input type="text" id="dialogueInput" class="form-input flex-1" placeholder="Stellen Sie eine Frage...">
                <button id="sendDialogueButton" class="btn w-1/4">Senden</button>
            </div>
        </div>
    </div>

    <!-- Level Select UI -->
    <div id="levelSelectOverlay" class="level-select-overlay">
        <div class="level-select-box">
            <h3 class="dialogue-title">Wähle ein Level</h3>
            <div id="levelSelectGrid" class="level-select-grid"></div>
            <button id="closeLevelSelectButton" class="btn mt-4">Schließen</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, runTransaction, updateDoc, deleteDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase-Konfiguration (Bitte ersetzen Sie die Platzhalter durch Ihre eigenen Daten)
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : null);
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        let app, db, auth;
        let highestLevel = 1;
        let userId;
        let userEmail;
        let gameMode = 'singleplayer';
        let multiplayerLobbyCode = null;
        let multiplayerTimerId = null;

        // UI-Element-Referenzen
        const authContainer = document.getElementById('authContainer');
        const authForms = document.getElementById('authForms');
        const loadingMessage = document.getElementById('loadingMessage');
        const gameContainer = document.getElementById('gameContainer');
        const loginForm = document.getElementById('loginForm');
        const registerForm = document.getElementById('registerForm');
        const showRegisterLink = document.getElementById('showRegister');
        const showLoginLink = document.getElementById('showLogin');
        const loginEmailInput = document.getElementById('loginEmail');
        const loginPasswordInput = document.getElementById('loginPassword');
        const loginButton = document.getElementById('loginButton');
        const registerEmailInput = document.getElementById('registerEmail');
        const registerPasswordInput = document.getElementById('registerPassword');
        const registerButton = document.getElementById('registerButton');
        const authError = document.getElementById('authError');
        const registerError = document.getElementById('registerError');
        const userInfoDisplay = document.getElementById('userInfo');
        const logoutButton = document.getElementById('logoutButton');

        const modeSelectContainer = document.getElementById('modeSelectContainer');
        const modeSelectInfo = document.getElementById('modeSelectInfo');
        const singlePlayerButton = document.getElementById('singlePlayerButton');
        const multiplayerButton = document.getElementById('multiplayerButton');
        const multiplayerContainer = document.getElementById('multiplayerContainer');
        const joinLobbyCodeInput = document.getElementById('joinLobbyCode');
        const joinLobbyButton = document.getElementById('joinLobbyButton');
        const createLobbyButton = document.getElementById('createLobbyButton');
        const multiplayerMessage = document.getElementById('multiplayerMessage');
        const multiplayerBackButton = document.getElementById('multiplayerBackButton');
        const lobbyContainer = document.getElementById('lobbyContainer');
        const lobbyTitle = document.getElementById('lobbyTitle');
        const lobbyCodeDisplay = document.getElementById('lobbyCodeDisplay');
        const playerList = document.getElementById('playerList');
        const lobbyStatusMessage = document.getElementById('lobbyStatusMessage');
        const startGameButton = document.getElementById('startGameButton');
        const leaveLobbyButton = document.getElementById('leaveLobbyButton');
        const multiplayerTimerDisplay = document.getElementById('multiplayerTimerDisplay');
        const gameTimerDisplay = document.getElementById('gameTimer');
        const returnToModeSelectButton = document.getElementById('returnToModeSelectButton');
        
        const gameOverlay = document.getElementById('gameOverlay');
        const overlayText = document.getElementById('overlay-text');
        const overlayCloseButton = document.getElementById('overlay-close-button');


        async function startAppFlow() {
            if (!auth || !db) {
                console.error("Firebase nicht initialisiert. App-Start nicht möglich.");
                loadingMessage.textContent = "Fehler: Firebase-Konfiguration ungültig. Bitte überprüfen Sie Ihre Daten.";
                return;
            }

            const showScreen = (screenId) => {
                const screens = document.querySelectorAll('.screen-container, .game-container');
                screens.forEach(screen => {
                    screen.classList.remove('active');
                    screen.style.display = 'none';
                });
                const screen = document.getElementById(screenId);
                if (screen) {
                    screen.style.display = 'flex';
                    setTimeout(() => screen.classList.add('active'), 10);
                }
            };
            
            showRegisterLink.addEventListener('click', (e) => {
                e.preventDefault();
                loginForm.style.display = 'none';
                registerForm.style.display = 'block';
                authError.style.display = 'none';
            });

            showLoginLink.addEventListener('click', (e) => {
                e.preventDefault();
                loginForm.style.display = 'block';
                registerForm.style.display = 'none';
                registerError.style.display = 'none';
            });

            const handleAuth = async (isLogin) => {
                const emailInput = isLogin ? loginEmailInput : registerEmailInput;
                const passwordInput = isLogin ? loginPasswordInput : registerPasswordInput;
                const errorElement = isLogin ? authError : registerError;
                const button = isLogin ? loginButton : registerButton;
                
                errorElement.textContent = '';
                errorElement.style.display = 'none';
                button.disabled = true;

                try {
                    if (isLogin) {
                        await signInWithEmailAndPassword(auth, emailInput.value, passwordInput.value);
                    } else {
                        await createUserWithEmailAndPassword(auth, emailInput.value, passwordInput.value);
                    }
                } catch (error) {
                    let message = 'Ein Fehler ist aufgetreten. Bitte versuchen Sie es erneut.';
                    if (error.code === 'auth/email-already-in-use') {
                        message = 'Diese E-Mail-Adresse wird bereits verwendet.';
                    } else if (error.code === 'auth/invalid-email') {
                        message = 'Ungültige E-Mail-Adresse.';
                    } else if (error.code === 'auth/weak-password') {
                        message = 'Das Passwort sollte mindestens 6 Zeichen lang sein.';
                    } else if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password') {
                        message = 'Ungültige E-Mail oder Passwort.';
                    }
                    errorElement.textContent = message;
                    errorElement.style.display = 'block';
                    console.error("Authentication failed:", error);
                } finally {
                    button.disabled = false;
                }
            };

            loginButton.addEventListener('click', () => handleAuth(true));
            registerButton.addEventListener('click', () => handleAuth(false));
            logoutButton.addEventListener('click', async () => {
                try {
                    await signOut(auth);
                } catch (error) {
                    console.error("Abmelden fehlgeschlagen:", error);
                }
            });
            
            singlePlayerButton.addEventListener('click', () => {
                gameMode = 'singleplayer';
                showScreen('gameContainer');
                multiplayerTimerDisplay.style.display = 'none';
                returnToModeSelectButton.style.display = 'block';
                openLevelSelectButton.style.display = 'block';
                openDialogueButton.style.display = 'block';
                initializeGame();
            });

            multiplayerButton.addEventListener('click', () => {
                gameMode = 'multiplayer';
                showScreen('multiplayerContainer');
            });
            
            multiplayerBackButton.addEventListener('click', () => showScreen('modeSelectContainer'));
            returnToModeSelectButton.addEventListener('click', () => {
                if (playerStateUnsubscribe) playerStateUnsubscribe();
                showScreen('modeSelectContainer');
            });

            createLobbyButton.addEventListener('click', async () => {
                multiplayerMessage.style.display = 'none';
                const lobbyCode = generateLobbyCode();
                try {
                    const lobbyDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyCode);
                    await setDoc(lobbyDocRef, {
                        hostId: userId,
                        players: [{ userId: userId, email: userEmail, stieleCount: 0 }],
                        gameActive: false,
                        gameStartTime: null,
                        stiele: []
                    });
                    multiplayerLobbyCode = lobbyCode;
                    setupLobbyListener(lobbyCode);
                    showScreen('lobbyContainer');
                } catch (e) {
                    multiplayerMessage.textContent = "Lobby konnte nicht erstellt werden. Bitte versuchen Sie es erneut.";
                    multiplayerMessage.style.display = 'block';
                    console.error("Fehler beim Erstellen der Lobby:", e);
                }
            });

            joinLobbyButton.addEventListener('click', async () => {
                multiplayerMessage.style.display = 'none';
                const lobbyCode = joinLobbyCodeInput.value.trim().toUpperCase();
                if (lobbyCode.length !== 6) {
                    multiplayerMessage.textContent = "Ungültiger Lobby-Code.";
                    multiplayerMessage.style.display = 'block';
                    return;
                }
                try {
                    const lobbyDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyCode);
                    const lobbyDoc = await getDoc(lobbyDocRef);
                    if (!lobbyDoc.exists()) {
                        multiplayerMessage.textContent = "Lobby nicht gefunden.";
                        multiplayerMessage.style.display = 'block';
                        return;
                    }

                    const lobbyData = lobbyDoc.data();
                    if (lobbyData.gameActive) {
                        multiplayerMessage.textContent = "Spiel in dieser Lobby ist bereits aktiv.";
                        multiplayerMessage.style.display = 'block';
                        return;
                    }

                    await updateDoc(lobbyDocRef, {
                        players: [...lobbyData.players, { userId: userId, email: userEmail, stieleCount: 0 }]
                    });

                    multiplayerLobbyCode = lobbyCode;
                    setupLobbyListener(lobbyCode);
                    showScreen('lobbyContainer');
                } catch (e) {
                    multiplayerMessage.textContent = "Lobby konnte nicht beigetreten werden. Bitte versuchen Sie es erneut.";
                    multiplayerMessage.style.display = 'block';
                    console.error("Fehler beim Beitritt zur Lobby:", e);
                }
            });

            startGameButton.addEventListener('click', async () => {
                const lobbyDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', multiplayerLobbyCode);
                try {
                    await setDoc(lobbyDocRef, { gameActive: true, gameStartTime: Date.now() }, { merge: true });
                } catch (e) {
                    console.error("Fehler beim Starten des Spiels:", e);
                }
            });

            leaveLobbyButton.addEventListener('click', async () => {
                if (multiplayerLobbyCode) {
                    const lobbyDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', multiplayerLobbyCode);
                    try {
                        const lobbyDoc = await getDoc(lobbyDocRef);
                        if (lobbyDoc.exists()) {
                            const lobbyData = lobbyDoc.data();
                            const updatedPlayers = lobbyData.players.filter(p => p.userId !== userId);
                            if (updatedPlayers.length > 0) {
                                await updateDoc(lobbyDocRef, { players: updatedPlayers });
                            } else {
                                await deleteDoc(lobbyDocRef);
                            }
                        }
                    } catch (e) {
                        console.error("Fehler beim Verlassen der Lobby:", e);
                    }
                    resetMultiplayerState();
                }
            });

            function generateLobbyCode() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                let result = '';
                for (let i = 0; i < 6; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }

            let lobbyUnsubscribe = null;
            function setupLobbyListener(code) {
                if (lobbyUnsubscribe) lobbyUnsubscribe();
                const lobbyDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', code);
                lobbyUnsubscribe = onSnapshot(lobbyDocRef, (doc) => {
                    const lobbyData = doc.data();
                    if (!lobbyData) {
                        multiplayerMessage.textContent = "Lobby wurde aufgelöst.";
                        multiplayerMessage.style.display = 'block';
                        resetMultiplayerState();
                        return;
                    }

                    lobbyCodeDisplay.textContent = code;
                    playerList.innerHTML = lobbyData.players.map(p => `<div class="player-list-item">${p.email}</div>`).join('');
                    
                    if (lobbyData.hostId === userId) {
                        startGameButton.style.display = lobbyData.players.length >= 1 ? 'block' : 'none';
                        lobbyTitle.textContent = "Ihre Lobby";
                        lobbyStatusMessage.textContent = "Teilen Sie diesen Code, um Freunde einzuladen!";
                        lobbyStatusMessage.style.display = 'block';
                    } else {
                        startGameButton.style.display = 'none';
                        lobbyTitle.textContent = "Lobby beigetreten";
                        lobbyStatusMessage.textContent = "Warten auf den Host, um das Spiel zu starten...";
                        lobbyStatusMessage.style.display = 'block';
                    }

                    if (lobbyData.gameActive) {
                         showScreen('gameContainer');
                         initializeGame(lobbyData);
                    }
                });
            }

            function resetMultiplayerState() {
                multiplayerLobbyCode = null;
                showScreen('multiplayerContainer');
                if (multiplayerTimerId) clearInterval(multiplayerTimerId);
            }

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    userEmail = user.email || 'Anonym';
                    userInfoDisplay.textContent = `Angemeldet als: ${userEmail}`;
                    showScreen('modeSelectContainer');
                    modeSelectInfo.textContent = `Willkommen, ${userEmail}!`;

                    const gameDocRef = doc(db, 'artifacts', appId, 'users', userId, 'gameData', 'progress');
                    try {
                        const docSnap = await getDoc(gameDocRef);
                        if (docSnap.exists()) {
                            highestLevel = docSnap.data().highestLevel;
                        } else {
                            await setDoc(gameDocRef, { highestLevel: 1 });
                        }
                    } catch (error) {
                        console.error("Fehler beim Laden/Erstellen der Benutzerdaten:", error);
                    }
                } else {
                    userId = null;
                    userEmail = null;
                    userInfoDisplay.textContent = '';
                    showScreen('authContainer');
                    loadingMessage.style.display = 'none';
                    authForms.style.display = 'block';

                    if (!initialAuthToken) {
                        await signInAnonymously(auth)
                            .catch(e => console.error("Anonyme Anmeldung fehlgeschlagen:", e));
                    }
                }
            });
        }

        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            startAppFlow();
        } catch (e) {
            console.error("Firebase-Initialisierung fehlgeschlagen. Bitte überprüfen Sie die Konfiguration.", e);
            loadingMessage.textContent = "Fehler: Verbindung zur Datenbank fehlgeschlagen. Bitte versuchen Sie es später erneut.";
            loadingMessage.style.color = "var(--danger)";
            loadingMessage.style.fontWeight = "bold";
        }


        async function initializeGame(lobbyData = null) {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const lungenKapazitaetBar = document.getElementById('lungen-kapazitaet-bar');
            const lungenKapazitaetText = document.getElementById('lungen-kapazitaet-text');
            const stieleCounterText = document.getElementById('stiele-counter');
            const infoMessage = document.getElementById('info-message');

            const openDialogueButton = document.getElementById('openDialogueButton');
            const dialogueOverlay = document.getElementById('dialogueOverlay');
            const dialogueText = document.getElementById('dialogueText');
            const dialogueInput = document.getElementById('dialogueInput');
            const sendDialogueButton = document.getElementById('sendDialogueButton');
            const closeDialogueButton = document.getElementById('closeDialogueButton');
            const openLevelSelectButton = document.getElementById('openLevelSelectButton');
            const levelSelectOverlay = document.getElementById('levelSelectOverlay');
            const levelSelectGrid = document.getElementById('levelSelectGrid');
            const closeLevelSelectButton = document.getElementById('closeLevelSelectButton');

            let animationFrameId;
            let lastTime = 0;
            let keys = {};
            let isRunning = false;
            let gameData = { level: 1 };
            let isSpeaking = false;
            let lowLungsWarning = false;
            let playerStateUnsubscribe = null;

            const baseSpeed = 250;
            const maxLungenKapazitaet = 100;
            const TOTAL_LEVELS = 50;
            const MULTIPLAYER_DURATION = 180;
            const MULTIPLAYER_REQUIRED_STIELE = 500;

            function showOverlay(text, isWin) {
                overlayText.textContent = text;
                gameOverlay.style.backgroundColor = isWin ? 'rgba(76, 175, 80, 0.7)' : 'rgba(255, 0, 0, 0.7)';
                gameOverlay.classList.add('active');
            }

            overlayCloseButton.addEventListener('click', () => {
                gameOverlay.classList.remove('active');
            });
            
            function getNonOverlappingPosition(existingObjects, width, height) {
                let newPos, overlapping;
                const safetyCounter = 100;
                let attempts = 0;
                do {
                    overlapping = false;
                    newPos = {
                        x: Math.random() * (canvas.width - width),
                        y: Math.random() * (canvas.height - height),
                        width: width,
                        height: height
                    };
                    
                    if (checkCollision(gameData.herrWinkelmann, newPos)) {
                        overlapping = true;
                        continue;
                    }
                    
                    for (const obj of existingObjects) {
                        if (checkCollision(obj, newPos)) {
                            overlapping = true;
                            break;
                        }
                    }
                    attempts++;
                } while (overlapping && attempts < safetyCounter);
                return newPos;
            }

            const TTS_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=";
            const API_KEY = "";

            async function speak(text, voiceName = "Kore") {
                if (isSpeaking) return;
                isSpeaking = true;
                
                try {
                    const payload = {
                        contents: [{ parts: [{ text }] }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName }
                                }
                            }
                        },
                        model: "gemini-2.5-flash-preview-tts"
                    };

                    const response = await fetch(TTS_API_URL + API_KEY, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) throw new Error(`API error: ${response.statusText}`);
                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        const audioUrl = URL.createObjectURL(wavBlob);
                        const audio = new Audio(audioUrl);
                        audio.play();
                        audio.onended = () => { URL.revokeObjectURL(audioUrl); isSpeaking = false; };
                    } else {
                        throw new Error("Ungültige Audiodaten von der API");
                    }
                } catch (error) {
                    console.error("Sprachausgabe fehlgeschlagen:", error);
                    isSpeaking = false;
                }
            }

            function base64ToArrayBuffer(base64) {
                const binaryString = window.atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }

            function pcmToWav(pcmData, sampleRate) {
                const numChannels = 1;
                const bytesPerSample = 2;
                const blockAlign = numChannels * bytesPerSample;
                const byteRate = sampleRate * blockAlign;
                const wavHeader = new ArrayBuffer(44);
                const view = new DataView(wavHeader);

                writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + pcmData.byteLength, true);
                writeString(view, 8, 'WAVE');
                writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, numChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, byteRate, true);
                view.setUint16(32, blockAlign, true);
                view.setUint16(34, 16, true);
                writeString(view, 36, 'data');
                view.setUint32(40, pcmData.byteLength, true);

                const blob = new Blob([wavHeader, pcmData], { type: 'audio/wav' });
                return blob;
            }

            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }
            
            const LLM_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=";
            const API_KEY = "";
            const systemPrompt = `Du bist Herr Winkelmann, ein sehr höflicher, leicht außer Atem geratener Mann, der damit beschäftigt ist, Stiele einzusammeln. Antworte immer kurz, freundlich und in der Ich-Form. Deine Antworten sollten widerspiegeln, dass du dich gerade anstrengst, aber fest entschlossen bist. Beziehe dich auf deine aktuelle Aufgabe, wenn es passt. Du bist ein einfacher Mann. Vermeide übermäßig komplexe Sprache.`;
            let isGeneratingResponse = false;

            async function generateAndSpeakResponse(userQuery) {
                if (isGeneratingResponse) return;
                isGeneratingResponse = true;
                sendDialogueButton.disabled = true;
                dialogueInput.disabled = true;
                dialogueText.textContent = "Herr Winkelmann denkt nach...";

                try {
                    const payload = {
                        contents: [{ parts: [{ text: userQuery }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                    };

                    const response = await fetch(LLM_API_URL + API_KEY, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) throw new Error(`API error: ${response.statusText}`);
                    const result = await response.json();
                    const text = result?.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (text) {
                        dialogueText.textContent = text;
                        await speak(text, "Leda");
                    } else {
                        throw new Error("Ungültige Antwort von der LLM API");
                    }
                } catch (error) {
                    console.error("Generierung des Dialogs fehlgeschlagen:", error);
                    dialogueText.textContent = "Huch, etwas ist schiefgelaufen. Ich kann jetzt nicht reden.";
                } finally {
                    isGeneratingResponse = false;
                    sendDialogueButton.disabled = false;
                    dialogueInput.disabled = false;
                }
            }

            async function saveHighestLevel(level) {
                if (level > highestLevel) {
                    highestLevel = level;
                    const gameDocRef = doc(db, 'artifacts', appId, 'users', userId, 'gameData', 'progress');
                    await setDoc(gameDocRef, { highestLevel: highestLevel }, { merge: true });
                    return true;
                }
                return false;
            }

            function resizeCanvas() {
                canvas.width = window.innerWidth * 0.7;
                canvas.height = window.innerHeight * 0.7;
                if (canvas.width > 800) canvas.width = 800;
                if (canvas.height > 600) canvas.height = 600;
                resetGame();
            }

            class GameObject {
                constructor(x, y, width, height, color, id = null) {
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                    this.color = color;
                    this.id = id;
                }
                draw() {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }
            
            function getLevelSettings(level) {
                return {
                    requiredStiele: Math.min(50, 5 + Math.floor(level * 1.5)),
                    initialStiele: 5,
                    obstacles: Math.min(20, Math.floor((level - 1) / 3) + 1),
                    lungenDrainRate: 1 + (level - 1) * 0.1,
                    lungLossOnHit: 15,
                };
            }

            function generateStiele(count) {
                const existingObjects = [...gameData.stiele, ...gameData.obstacles];
                for (let i = 0; i < count; i++) {
                    const pos = getNonOverlappingPosition(existingObjects, 15, 15);
                    if (pos) {
                        gameData.stiele.push(new GameObject(pos.x, pos.y, 15, 15, 'orange', crypto.randomUUID()));
                    }
                }
            }

            function resetGame(level = 1) {
                cancelAnimationFrame(animationFrameId);
                isRunning = false;
                gameData.level = level;
                
                const settings = getLevelSettings(gameData.level);
                
                gameData = {
                    ...gameData,
                    herrWinkelmann: {
                        x: canvas.width / 2,
                        y: canvas.height / 2,
                        width: 30,
                        height: 30,
                        speed: baseSpeed,
                    },
                    stiele: [],
                    obstacles: [],
                    stielCounter: 0,
                    lungenKapazitaet: maxLungenKapazitaet,
                    requiredStiele: settings.requiredStiele,
                    players: {},
                    gameStartTime: 0,
                    multiplayerPlayers: {},
                };
                
                if (gameMode === 'singleplayer') {
                    const existingObjects = [gameData.herrWinkelmann];
                    for (let i = 0; i < settings.obstacles; i++) {
                        const obstacleSize = Math.random() * 30 + 30;
                        const pos = getNonOverlappingPosition(existingObjects, obstacleSize, obstacleSize);
                        if (pos) {
                            const newObstacle = new GameObject(pos.x, pos.y, obstacleSize, obstacleSize, 'black');
                            gameData.obstacles.push(newObstacle);
                            existingObjects.push(newObstacle);
                        }
                    }
                    generateStiele(settings.initialStiele);
                    
                    showOverlay("Willkommen! Sammle die Stiele!", false);
                }
                draw();
                updateUI();
            }
            
            async function startGame() {
                gameOverlay.classList.remove('active');
                if (gameMode === 'multiplayer') {
                    startMultiplayerGame();
                } else if (!isRunning) {
                    isRunning = true;
                    lastTime = performance.now();
                    animationFrameId = requestAnimationFrame(gameLoop);
                    infoMessage.textContent = "Sammle die Stiele, bevor die Lungenkapazität aufgebraucht ist!";
                    speak("Los geht's! Nur nicht schlapp machen!");
                }
            }
            
            async function startMultiplayerGame() {
                multiplayerTimerDisplay.style.display = 'block';
                openLevelSelectButton.style.display = 'none';
                openDialogueButton.style.display = 'none';
                returnToModeSelectButton.style.display = 'block';
                
                resetGame();
                
                const playerDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', multiplayerLobbyCode, 'players', userId);
                await setDoc(playerDocRef, {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    stieleCount: 0,
                    lungs: maxLungenKapazitaet,
                    email: userEmail
                });

                const lobbyDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', multiplayerLobbyCode);
                const lobbySnapshot = await getDoc(lobbyDocRef);
                const lobbyData = lobbySnapshot.data();
                
                gameData.stiele = lobbyData.stiele;

                playerStateUnsubscribe = onSnapshot(collection(db, `artifacts/${appId}/public/data/lobbies/${multiplayerLobbyCode}/players`), (snapshot) => {
                    snapshot.docChanges().forEach(change => {
                        const player = change.doc.data();
                        gameData.multiplayerPlayers[change.doc.id] = player;
                    });
                });

                isRunning = true;
                lastTime = performance.now();
                animationFrameId = requestAnimationFrame(gameLoop);
                
                multiplayerTimerId = setInterval(() => {
                    const elapsedTime = (Date.now() - lobbyData.gameStartTime) / 1000;
                    const remainingTime = Math.max(0, MULTIPLAYER_DURATION - elapsedTime);
                    const minutes = Math.floor(remainingTime / 60);
                    const seconds = Math.floor(remainingTime % 60);
                    gameTimerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    if (remainingTime <= 0) {
                        endMultiplayerGame();
                    }
                }, 1000);
            }
            
            async function endMultiplayerGame() {
                isRunning = false;
                cancelAnimationFrame(animationFrameId);
                if (multiplayerTimerId) clearInterval(multiplayerTimerId);
                if (playerStateUnsubscribe) playerStateUnsubscribe();

                const lobbyDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', multiplayerLobbyCode);
                const lobbySnapshot = await getDoc(lobbyDocRef);
                const lobbyData = lobbySnapshot.data();
                const players = lobbyData.players.sort((a, b) => b.stieleCount - a.stieleCount);
                const winner = players[0];

                let message;
                if (winner) {
                    if (winner.userId === userId) {
                        message = `Herzlichen Glückwunsch! Sie haben mit ${winner.stieleCount} Stielen gewonnen!`;
                    } else {
                        message = `Das Spiel ist vorbei! ${winner.email} hat mit ${winner.stieleCount} Stielen gewonnen!`;
                    }
                } else {
                    message = "Das Spiel ist vorbei! Kein Gewinner, da keine Stiele gesammelt wurden.";
                }
                
                showOverlay(message, true);
                
                setTimeout(async () => {
                    await deleteDoc(lobbyDocRef);
                    showScreen('modeSelectContainer');
                }, 5000);
            }

            function gameLoop(time) {
                const deltaTime = (time - lastTime) / 1000;
                lastTime = time;

                if (isRunning) {
                    update(deltaTime);
                    draw();
                    animationFrameId = requestAnimationFrame(gameLoop);
                }
            }

            async function update(deltaTime) {
                const speed = baseSpeed;
                let dx = 0;
                let dy = 0;
                if (keys['arrowup'] || keys['w']) dy = -1;
                if (keys['arrowdown'] || keys['s']) dy = 1;
                if (keys['arrowleft'] || keys['a']) dx = -1;
                if (keys['arrowright'] || keys['d']) dx = 1;

                if (dx !== 0 || dy !== 0) {
                    const length = Math.sqrt(dx * dx + dy * dy);
                    if (length > 0) {
                        gameData.herrWinkelmann.x += (dx / length) * speed * deltaTime;
                        gameData.herrWinkelmann.y += (dy / length) * speed * deltaTime;
                    }
                }

                gameData.herrWinkelmann.x = Math.max(0, Math.min(canvas.width - gameData.herrWinkelmann.width, gameData.herrWinkelmann.x));
                gameData.herrWinkelmann.y = Math.max(0, Math.min(canvas.height - gameData.herrWinkelmann.height, gameData.herrWinkelmann.y));
                
                if (gameMode === 'multiplayer') {
                    const playerDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', multiplayerLobbyCode, 'players', userId);
                    await setDoc(playerDocRef, { x: gameData.herrWinkelmann.x, y: gameData.herrWinkelmann.y, lungs: gameData.lungenKapazitaet }, { merge: true });

                    gameData.stiele.forEach((stiel, index) => {
                        if (checkCollision(gameData.herrWinkelmann, stiel)) {
                             const lobbyDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', multiplayerLobbyCode);
                             runTransaction(db, async (transaction) => {
                                 const lobbyDoc = await transaction.get(lobbyDocRef);
                                 if (!lobbyDoc.exists()) throw "Lobby does not exist!";
                                 const currentStiele = lobbyDoc.data().stiele;
                                 const stielIndex = currentStiele.findIndex(s => s.id === stiel.id);
                                 
                                 if (stielIndex !== -1) {
                                     const updatedStiele = [...currentStiele];
                                     updatedStiele.splice(stielIndex, 1);
                                     
                                     const players = lobbyDoc.data().players;
                                     const myPlayer = players.find(p => p.userId === userId);
                                     if (myPlayer) {
                                         myPlayer.stieleCount++;
                                     }
                                     
                                     transaction.update(lobbyDocRef, { stiele: updatedStiele, players: players });
                                 }
                             });
                        }
                    });

                } else {
                    const settings = getLevelSettings(gameData.level);
                    gameData.lungenKapazitaet -= settings.lungenDrainRate * deltaTime;
                    if (gameData.lungenKapazitaet <= 0) {
                        endLevel(false, "Da gibt's nichts mehr...");
                        return;
                    }
                    
                    if (gameData.lungenKapazitaet < 20 && !lowLungsWarning) {
                        speak("Uff... die Luft wird knapp!", "Orus");
                        lowLungsWarning = true;
                    } else if (gameData.lungenKapazitaet > 20) {
                        lowLungsWarning = false;
                    }
                    
                    gameData.stiele.forEach((stiel, index) => {
                        if (checkCollision(gameData.herrWinkelmann, stiel)) {
                            gameData.stiele.splice(index, 1);
                            gameData.stielCounter++;
                            gameData.lungenKapazitaet = Math.min(maxLungenKapazitaet, gameData.lungenKapazitaet + 10);
                            
                            if (gameData.stielCounter >= gameData.requiredStiele) {
                                endLevel(true, "Winkelmann dankt.");
                                return;
                            }
                        }
                    });

                    if (gameData.stiele.length === 0 && gameData.stielCounter < gameData.requiredStiele) {
                        const stieleToGenerate = Math.min(5, gameData.requiredStiele - gameData.stielCounter);
                        generateStiele(stieleToGenerate);
                    }

                    gameData.obstacles.forEach(obstacle => {
                        if (checkCollision(gameData.herrWinkelmann, obstacle)) {
                            gameData.lungenKapazitaet -= settings.lungLossOnHit;
                            speak("Aua! Das tat weh!", "Charon");
                        }
                    });
                }
                
                updateUI();
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                gameData.stiele.forEach(stiel => {
                    ctx.beginPath();
                    ctx.arc(stiel.x + stiel.width / 2, stiel.y + stiel.height / 2, stiel.width / 2, 0, 2 * Math.PI);
                    ctx.fillStyle = 'var(--accent)';
                    ctx.fill();
                    ctx.strokeStyle = 'var(--surface)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
                
                if (gameMode === 'singleplayer') {
                     gameData.obstacles.forEach(obstacle => {
                        ctx.fillStyle = 'var(--text)';
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    });
                }

                const players = Object.values(gameData.multiplayerPlayers);
                if (gameMode === 'multiplayer' && players.length > 0) {
                    players.forEach(player => {
                        const color = player.userId === userId ? 'var(--primary)' : 'var(--secondary)';
                        ctx.fillStyle = color;
                        ctx.fillRect(player.x, player.y, 30, 30);
                        
                        ctx.fillStyle = 'var(--text)';
                        ctx.font = '12px "Inter", sans-serif';
                        ctx.fillText(player.email.split('@')[0], player.x, player.y - 5);
                    });
                } else {
                    ctx.fillStyle = 'var(--primary)';
                    ctx.fillRect(gameData.herrWinkelmann.x, gameData.herrWinkelmann.y, gameData.herrWinkelmann.width, gameData.herrWinkelmann.height);
                }
            }

            function updateUI() {
                const lungenProzent = Math.max(0, (gameData.lungenKapazitaet / maxLungenKapazitaet) * 100);
                lungenKapazitaetBar.style.width = `${lungenProzent}%`;
                lungenKapazitaetText.textContent = `${Math.floor(lungenProzent)}%`;

                const lungenColor = lungenProzent > 50 ? 'var(--success)' : (lungenProzent > 20 ? 'var(--accent)' : 'var(--danger)');
                lungenKapazitaetBar.style.backgroundColor = lungenColor;

                if (gameMode === 'multiplayer') {
                    const myPlayer = gameData.multiplayerPlayers[userId];
                    stieleCounterText.textContent = `${myPlayer ? myPlayer.stieleCount : 0}`;
                    infoMessage.textContent = "Sammeln Sie mehr Stiele als Ihr Gegner!";
                } else {
                    stieleCounterText.textContent = `${gameData.stielCounter} / ${gameData.requiredStiele}`;
                    infoMessage.textContent = `Level ${gameData.level}: Sammeln Sie alle Stiele, um das Level zu beenden.`;
                }
            }

            function endLevel(isWin, message) {
                isRunning = false;
                cancelAnimationFrame(animationFrameId);
                showOverlay(message, isWin);

                if (isWin) {
                    const levelUnlocked = saveHighestLevel(gameData.level + 1);
                    speak("Das war eine Meisterleistung!", "Zephyr");
                    if (levelUnlocked) {
                         setTimeout(() => {
                            const newLevelButton = document.getElementById(`level-button-${gameData.level + 1}`);
                            if (newLevelButton) {
                                newLevelButton.disabled = false;
                            }
                         }, 1000);
                    }
                } else {
                    speak("Da gibt's nichts mehr.", "Charon");
                }
                
                setTimeout(openLevelSelect, 2000);
            }

            function checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            function populateLevelSelect() {
                levelSelectGrid.innerHTML = '';
                for (let i = 1; i <= TOTAL_LEVELS; i++) {
                    const button = document.createElement('button');
                    button.textContent = i;
                    button.id = `level-button-${i}`;
                    button.className = 'level-button';
                    if (i > highestLevel) {
                        button.disabled = true;
                    }
                    button.addEventListener('click', () => {
                        resetGame(i);
                        closeLevelSelect();
                        startGame();
                    });
                    levelSelectGrid.appendChild(button);
                }
            }

            function openDialogue() {
                dialogueOverlay.classList.add('active');
                isRunning = false;
                cancelAnimationFrame(animationFrameId);
            }

            function closeDialogue() {
                dialogueOverlay.classList.remove('active');
                if (gameData.lungenKapazitaet > 0) {
                    startGame();
                }
            }

            function openLevelSelect() {
                populateLevelSelect();
                levelSelectOverlay.classList.add('active');
                isRunning = false;
                cancelAnimationFrame(animationFrameId);
                gameOverlay.classList.remove('active');
            }

            function closeLevelSelect() {
                levelSelectOverlay.classList.remove('active');
                if (gameData.lungenKapazitaet > 0) {
                    startGame();
                }
            }

            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd'].includes(key)) {
                    keys[key] = true;
                    if (!isRunning && gameOverlay.classList.contains('active')) {
                         startGame();
                    }
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });
            
            openDialogueButton.addEventListener('click', openDialogue);
            closeDialogueButton.addEventListener('click', closeDialogue);
            sendDialogueButton.addEventListener('click', () => {
                const userQuery = dialogueInput.value.trim();
                if (userQuery) {
                    generateAndSpeakResponse(userQuery);
                    dialogueInput.value = '';
                }
            });
            dialogueInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    sendDialogueButton.click();
                }
            });
            openLevelSelectButton.addEventListener('click', openLevelSelect);
            closeLevelSelectButton.addEventListener('click', closeLevelSelect);
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            resetGame(highestLevel);
        }
    </script>
</body>
</html>
